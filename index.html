<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hunt - モブハントトラッカー</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* カスタムスタイル */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* ダークモード背景 */
        }

        /* テキストに藍色のアウトライン/シャドウを適用 */
        .text-outline {
            text-shadow: 
                1px 1px 0 #1f2937,  /* 藍色系シャドウ */
                -1px 1px 0 #1f2937, 
                1px -1px 0 #1f2937, 
                -1px -1px 0 #1f2937;
        }

        /* ランクアイコンの基本スタイル */
        .rank-icon {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
            transition: transform 0.1s ease-in-out;
        }

        /* マップ描画用のスタイル */
        .spawn-point {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            transform: translate(-50%, -50%); /* 中央配置 */
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.8); /* 点に影 */
        }

        /* マウスオーバー時の強調表示 */
        .spawn-point:hover {
            transform: translate(-50%, -50%) scale(1.3);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
        }

        /* S/Aモブが出る重要地点のリング */
        .important-ring {
            box-shadow: 
                0 0 0 4px #fbbf24, /* 濃い黄色/オレンジの太い外枠 */
                0 0 8px rgba(0, 0, 0, 0.8); /* 影を維持 */
        }
        
        /* リポップバーのCSS変数とグラデーション定義 */
        .repop-bar-bg {
            /* --progress-percentはJSで動的に設定されます */
            background: linear-gradient(to right, 
                var(--progress-color-start) 0%, 
                var(--progress-color-end) var(--progress-percent), 
                #2d3748 var(--progress-percent), 
                #2d3748 100%);
            transition: background 0.5s ease;
        }

        /* スライドパネルのアニメーション */
        .mob-details {
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            overflow: hidden;
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        .mob-details.open {
            max-height: 1000px; /* 十分な高さを確保 */
            padding-top: 1rem;
            padding-bottom: 1rem;
        }

    </style>
</head>
<body class="text-white">

    <!-- メインコンテナ -->
    <div id="app" class="min-h-screen">
        
        <!-- 固定ヘッダー: タイトルとタブ -->
        <header class="sticky top-0 z-50 bg-gray-900 shadow-xl p-4">
            <h1 class="text-3xl font-bold text-center text-yellow-300">The Hunt</h1>
            <p class="text-sm text-center text-gray-400 mt-1 mb-3">
                // 仮の説明: モブハントの討伐記録とリポップ予測、湧き潰し管理ツールです。
            </p>

            <!-- ランクフィルタタブ -->
            <div id="rank-tabs" class="flex justify-center space-x-2 sm:space-x-4 border-b border-gray-700 pb-2">
                <button data-rank="ALL" class="tab-btn bg-yellow-600 px-3 py-1 rounded-full text-sm font-semibold shadow-md">ALL</button>
                <button data-rank="S" class="tab-btn bg-orange-600 px-3 py-1 rounded-full text-sm font-semibold shadow-md">Sランク</button>
                <button data-rank="A" class="tab-btn bg-green-600 px-3 py-1 rounded-full text-sm font-semibold shadow-md">Aランク</button>
                <button data-rank="F" class="tab-btn bg-blue-600 px-3 py-1 rounded-full text-sm font-semibold shadow-md">FATE</button>
            </div>
        </header>

        <!-- モブカード表示エリア -->
        <!-- PC: w-[512px] の3カラム / スマホ: 1カラム -->
        <main id="mob-list-container" 
              class="container mx-auto p-4 grid grid-cols-1 lg:grid-cols-3 gap-4"
              style="max-width: 1600px;"> 
            
            <!-- ここにJavaScriptでモブカードが挿入されます -->

        </main>
        
        <!-- モーダル（討伐報告フォーム） -->
        <div id="report-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50">
            <div class="bg-gray-800 p-6 rounded-lg shadow-2xl w-full max-w-sm">
                <h2 class="text-xl font-bold mb-4 text-white" id="modal-mob-name"></h2>
                
                <label for="report-memo" class="block text-sm font-medium text-gray-300 mb-1">メモ (任意):</label>
                <textarea id="report-memo" rows="3" class="w-full p-2 bg-gray-700 text-white rounded-md border border-gray-600 focus:ring focus:ring-blue-500"></textarea>
                
                <div class="flex justify-end space-x-3 mt-4">
                    <button id="cancel-report" class="px-4 py-2 bg-gray-600 rounded-md text-white hover:bg-gray-500">キャンセル</button>
                    <button id="submit-report" class="px-4 py-2 bg-green-600 rounded-md text-white hover:bg-green-500 font-bold">報告完了</button>
                </div>
                <p id="report-status" class="mt-3 text-center text-sm hidden"></p>
            </div>
        </div>

    </div>

    <!-- JavaScript ロジック -->
    <script>
        // Google Apps Script (GAS) のエンドポイントURL
        const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbxyutpOIZYI9Ce51s4vawk6S460QgM4wYcaLFJKUBi00_LKhNXT9-6N0n178KdoXkP7wg/exec';

        // --- データ定義 ---
        // 開発環境ではモブデータはこのJSONから読み込まれる想定です。
        // 実際のサイトではmob_data.jsonをGitHub Pagesに配置し、fetchで読み込む必要があります。
        const MOCK_MOB_DATA = [
            {
                "No": 12121,
                "Rank": "S",
                "Name": "ブロンテス",
                "Area": "中央ザナラーン",
                "REPOP(s)": 241200, // 67時間 (Sモブの標準)
                "MAX(s)": 277200, // 77時間
                "Map": "Central Thanalan.webp",
                "spawn_points": [
                    {"id": "CT_S_01", "x": 30.5, "y": 75.2, "mob_ranks": ["S", "A", "B1"]},
                    {"id": "CT_A_01", "x": 55.0, "y": 42.1, "mob_ranks": ["A", "B2"]},
                    {"id": "CT_B_01", "x": 12.8, "y": 20.9, "mob_ranks": ["B1"]},
                    {"id": "CT_B_02", "x": 80.0, "y": 50.0, "mob_ranks": ["B2"]},
                ]
            },
            {
                "No": 12122,
                "Rank": "A",
                "Name": "マインドフレア",
                "Area": "ラケティカ大森林",
                "REPOP(s)": 3000, // 50分 (Aモブの標準)
                "MAX(s)": 4800, // 80分
                "Map": "Rak'tika.webp",
                "spawn_points": [
                    {"id": "RAK_A_01", "x": 40.0, "y": 30.0, "mob_ranks": ["A", "B1"]},
                    {"id": "RAK_B_01", "x": 70.0, "y": 60.0, "mob_ranks": ["B1"]},
                ]
            },
            {
                "No": 12123,
                "Rank": "S",
                "Name": "フォーミダブル",
                "Area": "アム・アレーン",
                "REPOP(s)": 241200,
                "MAX(s)": 277200,
                "Map": "Amh_Araeng.webp",
                "spawn_points": [
                    {"id": "AMH_S_01", "x": 10.0, "y": 90.0, "mob_ranks": ["S", "B2"]},
                    {"id": "AMH_B_01", "x": 90.0, "y": 10.0, "mob_ranks": ["B2"]},
                ]
            }
            // 実際は全てのモブデータを含めます
        ];
        
        // ランクごとの色定義 (CSSクラス名)
        const RANK_COLORS = {
            'S': 'bg-orange-600', // S: オレンジ
            'A': 'bg-green-600',  // A: 緑
            'F': 'bg-blue-600',   // F: 青 (FATEモブ用)
            // Bモブの色は地点の背景色として利用
            'B1': '#79A6FF', // 柔らかい青系統
            'B2': '#FF7979'  // 柔らかい赤系統
        };

        // マップ上の消し込み状態を保存するキー
        const LOCAL_STORAGE_KEY = 'hunt_spawn_status';
        let huntRecords = []; // GASから取得した討伐記録
        let mobData = MOCK_MOB_DATA; // mob_data.jsonの内容
        let currentFilter = 'ALL';
        let userId; // 報告者UUID

        // --- ユーティリティ関数 ---

        /**
         * モブのランクカラーCSSクラスを返す
         * @param {string} rank - モブのランク (S, A, F)
         * @returns {string} Tailwind CSS class
         */
        function getRankColorClass(rank) {
            return RANK_COLORS[rank] || 'bg-gray-500';
        }
        
        /**
         * リポップ経過時間とパーセンテージを計算する
         * @param {object} mob - mobDataのモブオブジェクト
         * @param {number} lastKillTimestamp - 前回の討伐日時 (UTCミリ秒)
         * @returns {object} 計算結果
         */
        function calculateRepop(mob, lastKillTimestamp) {
            if (!lastKillTimestamp) {
                return {
                    minRepop: '情報なし',
                    maxRepop: '情報なし',
                    elapsedPercent: 0,
                    timeRemaining: 'N/A'
                };
            }
            
            const now = Date.now();
            const minRepopTime = lastKillTimestamp + (mob["REPOP(s)"] * 1000);
            const maxRepopTime = lastKillTimestamp + (mob["MAX(s)"] * 1000);
            
            // 経過時間の計算 (最短リポップを基準とする)
            const repopWindowDuration = (mob["MAX(s)"] - mob["REPOP(s)"]) * 1000;
            const timeSinceMinRepop = now - minRepopTime;

            let elapsedPercent;
            if (now < minRepopTime) {
                // まだ最短リポップ時間に達していない場合
                elapsedPercent = 0;
            } else if (now >= maxRepopTime) {
                // 最大リポップ時間を超えた場合 (湧き待ち中)
                elapsedPercent = 100;
            } else {
                // リポップウィンドウ期間中の経過率
                elapsedPercent = (timeSinceMinRepop / repopWindowDuration) * 100;
                elapsedPercent = Math.min(100, elapsedPercent); // 100%を超えないように
            }

            // 残り時間の計算（最大リポップまで）
            const remainingMillis = Math.max(0, maxRepopTime - now);
            const hours = Math.floor(remainingMillis / (1000 * 60 * 60));
            const minutes = Math.floor((remainingMillis % (1000 * 60 * 60)) / (1000 * 60));
            
            const timeRemainingStr = remainingMillis > 0 
                ? `${hours}h ${minutes}m` 
                : '湧き待ち/POP済み';

            return {
                minRepop: new Date(minRepopTime),
                maxRepop: new Date(maxRepopTime),
                elapsedPercent: elapsedPercent,
                timeRemaining: timeRemainingStr,
                sortKey: elapsedPercent // ソートに使用する値
            };
        }
        
        /**
         * 経過時間に応じて色を生成する (0% -> 青, 100% -> 赤)
         * @param {number} percent - 経過パーセンテージ (0-100)
         * @returns {object} {startColor, endColor}
         */
        function getColorForProgress(percent) {
            // HSL色空間で補間を行う
            const hStart = 200; // 青 (Hue 200)
            const hEnd = 0;   // 赤 (Hue 0)
            const hue = hStart + (hEnd - hStart) * (percent / 100);
            
            // 柔らかい色になるよう彩度と明度を調整
            const s = '70%'; 
            const l = '50%';

            // CSS変数で使用するHSL形式の文字列を返す
            return {
                startColor: `hsl(${200}, ${s}, ${l})`,
                endColor: `hsl(${hue}, ${s}, ${l})`
            };
        }

        // --- データ処理とUI描画 ---

        /**
         * 討伐データを取得し、UIを更新する
         */
        async function fetchAndRenderData() {
            // 1. データ取得
            let records = [];
            try {
                const response = await fetch(`${GAS_ENDPOINT}?action=getRecords`);
                const result = await response.json();
                if (result.status === "success") {
                    records = result.data;
                }
            } catch (error) {
                console.error("GASからのデータ取得エラー:", error);
                // エラー時でも続行し、過去の記録がないとして処理
            }
            huntRecords = records;
            
            // 2. 最終討伐時刻の特定と結合
            const lastKills = {};
            // 最新の討伐記録を抽出 (IDが大きいものが最新)
            huntRecords.sort((a, b) => b.ID - a.ID); 
            
            huntRecords.forEach(record => {
                if (!lastKills[record["モブ名"]]) {
                    lastKills[record["モブ名"]] = { 
                        timestamp: new Date(record["討伐日時 (UTC)"]).getTime(),
                        area: record["エリア名"] // (GASにはまだエリア名がないため、mobDataから取得すべきだが、ここでは割愛)
                    };
                }
            });

            // 3. モブリストの生成とソート
            const mobListWithRepop = mobData.map(mob => {
                const lastKill = lastKills[mob.Name];
                const lastKillTimestamp = lastKill ? lastKill.timestamp : 0;
                
                const repopData = calculateRepop(mob, lastKillTimestamp);
                
                return {
                    ...mob,
                    ...repopData,
                    lastKillTime: lastKill ? lastKill.timestamp : null
                };
            });
            
            // 4. 経過パーセンテージの降順でソート
            mobListWithRepop.sort((a, b) => b.sortKey - a.sortKey); 

            // 5. UIの再描画
            renderMobCards(mobListWithRepop);
        }

        /**
         * フィルタリングとUI描画を実行する
         * @param {Array} mobs - モブデータの配列
         */
        function renderMobCards(mobs) {
            const container = document.getElementById('mob-list-container');
            container.innerHTML = '';
            
            mobs.forEach(mob => {
                // フィルタリング
                if (currentFilter !== 'ALL' && mob.Rank !== currentFilter) {
                    return; 
                }

                // 討伐日時をローカルタイムゾーンで表示
                const lastKillTimeStr = mob.lastKillTime 
                    ? new Date(mob.lastKillTime).toLocaleString() 
                    : '未報告';
                
                // 次回POP時間をローカルタイムゾーンで表示
                const minPopStr = mob.minRepop instanceof Date ? mob.minRepop.toLocaleString() : mob.minRepop;
                
                // 進捗バーの色計算
                const progressColor = getColorForProgress(mob.elapsedPercent);

                // --- HTML要素の構築 ---
                const mobCard = document.createElement('div');
                mobCard.className = 'mob-card flex flex-col rounded-lg shadow-xl overflow-hidden';
                mobCard.dataset.mobname = mob.Name;
                
                // リポップバーのカスタムプロパティを設定
                mobCard.style.cssText = `
                    --progress-percent: ${mob.elapsedPercent}%;
                    --progress-color-start: ${progressColor.startColor};
                    --progress-color-end: ${progressColor.endColor};
                `;

                // 常時表示部分 (進捗バー背景)
                const fixedContent = `
                    <div class="fixed-content repop-bar-bg p-3 cursor-pointer select-none">
                        <!-- 1行目: ランク, モンスター名, 報告ボタン -->
                        <div class="flex justify-between items-center mb-1">
                            <div class="flex items-center space-x-2">
                                <div class="rank-icon ${getRankColorClass(mob.Rank)} w-6 h-6 sm:w-8 sm:h-8 rounded-md flex items-center justify-center text-xs sm:text-sm font-bold text-white">
                                    ${mob.Rank}
                                </div>
                                <span class="text-lg sm:text-xl font-bold text-white text-outline">${mob.Name}</span>
                            </div>
                            <button data-mob-name="${mob.Name}" data-mob-rank="${mob.Rank}" class="report-btn bg-red-600 hover:bg-red-700 px-3 py-1 rounded-full text-xs sm:text-sm font-bold shadow-lg">報 告</button>
                        </div>
                        
                        <!-- 2行目: エリア名 -->
                        <div class="text-sm sm:text-base text-gray-200 text-outline mb-1">${mob.Area}</div>
                        
                        <!-- 3行目: 次回POP時間 - 残り時間 (経過%) -->
                        <div class="text-xs sm:text-sm font-mono text-gray-100 text-outline">
                            ${minPopStr} - ${mob.timeRemaining} (${mob.elapsedPercent.toFixed(1)}%)
                        </div>
                    </div>
                `;

                // 詳細スライドパネル
                const detailContent = `
                    <div class="mob-details bg-gray-700 p-4 border-t border-gray-600">
                        <!-- 前回の討伐時間 -->
                        <p class="text-sm mb-2"><span class="font-semibold text-gray-300">前回の討伐時間:</span> ${lastKillTimeStr}</p>
                        
                        <!-- POPさせる条件の説明 (仮) -->
                        <p class="text-sm mb-4"><span class="font-semibold text-gray-300">POP条件:</span> ${mob["POP Date"] || '特に条件の記述なし'}</p>
                        
                        <!-- 座標記録用のMAP -->
                        <div class="map-container relative w-full rounded-lg overflow-hidden shadow-inner" style="padding-top: 100%;">
                            <img src="${mob.Map}" alt="${mob.Area} マップ" class="absolute inset-0 w-full h-full object-cover">
                            <div class="spawn-points-overlay absolute inset-0" data-map-id="${mob.Map}">
                                <!-- ここにJavaScriptで座標ドットが挿入されます -->
                            </div>
                        </div>
                    </div>
                `;
                
                mobCard.innerHTML = fixedContent + detailContent;
                container.appendChild(mobCard);
            });
            
            // マップとイベントリスナーの再設定
            setupMapPoints();
            setupEventListeners();
        }

        /**
         * マップ上の地点を描画し、消し込みロジックを適用する
         */
        function setupMapPoints() {
            const spawnStatus = getSpawnStatus();
            
            document.querySelectorAll('.spawn-points-overlay').forEach(overlay => {
                const mapId = overlay.dataset.mapId;
                overlay.innerHTML = ''; // クリア
                
                // 該当エリアのmobDataを探す
                const mob = mobData.find(m => m.Map === mapId);
                if (!mob || !mob.spawn_points) return;
                
                const importantPoints = mob.spawn_points.filter(p => p.mob_ranks.includes('S') || p.mob_ranks.includes('A'));
                const unkilledImportantPoints = importantPoints.filter(p => spawnStatus[p.id] !== 'killed');
                const isLastOne = unkilledImportantPoints.length === 1;

                mob.spawn_points.forEach(point => {
                    const status = spawnStatus[point.id] || 'active';
                    const isImportant = point.mob_ranks.includes('S') || point.mob_ranks.includes('A');
                    const isB1 = point.mob_ranks.includes('B1');
                    const isB2 = point.mob_ranks.includes('B2');
                    
                    // B1/B2の色を設定 (B1が優先)
                    let bgColor = isB1 ? RANK_COLORS.B1 : (isB2 ? RANK_COLORS.B2 : '#555');

                    // --- スタイル設定 ---
                    let dotClasses = 'spawn-point';
                    let dotStyle = `left: ${point.x}%; top: ${point.y}%; background-color: ${bgColor};`;
                    
                    // 1. 消込済み判定
                    if (status === 'killed') {
                        dotStyle += `background-color: #AAAAAA; opacity: 0.6;`;
                    } 
                    
                    // 2. 残り1点強調判定 (操作可能な地点のみ)
                    else if (isImportant && isLastOne && point.id === unkilledImportantPoints[0].id) {
                        dotStyle += `background-color: #66FF99; box-shadow: 0 0 10px 5px #66FF99;`;
                    }
                    
                    // 3. S/A重要地点強調判定 (外枠)
                    else if (isImportant) {
                        dotClasses += ' important-ring'; 
                    }

                    // 4. Bモブのみの地点はクリック不可（カーソル変更なし）
                    if (!isImportant) {
                        dotStyle += `cursor: default;`;
                    }

                    const dot = document.createElement('div');
                    dot.className = dotClasses;
                    dot.style.cssText = dotStyle;
                    dot.dataset.id = point.id;
                    dot.dataset.important = isImportant;
                    
                    // クリックイベントリスナー (重要地点のみ)
                    if (isImportant) {
                        dot.addEventListener('click', (e) => {
                            e.stopPropagation(); // 親要素の展開を防ぐ
                            toggleSpawnStatus(point.id);
                        });
                    }

                    overlay.appendChild(dot);
                });
            });
        }

        // --- 消し込み機能（ローカルストレージ） ---

        /**
         * ローカルストレージから消し込み状態を取得
         * @returns {object} 地点IDとその状態のマップ
         */
        function getSpawnStatus() {
            try {
                return JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY)) || {};
            } catch {
                return {};
            }
        }

        /**
         * 消し込み状態をトグルして保存し、マップを再描画する
         * @param {string} id - 地点のID
         */
        function toggleSpawnStatus(id) {
            const status = getSpawnStatus();
            
            // active -> killed, killed -> active
            if (status[id] === 'killed') {
                delete status[id];
            } else {
                status[id] = 'killed';
            }
            
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(status));
            setupMapPoints();
        }

        // --- イベントリスナー設定 ---

        /**
         * DOMイベントリスナーを設定する
         */
        function setupEventListeners() {
            // フィルタタブのクリックイベント
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.onclick = () => {
                    currentFilter = btn.dataset.rank;
                    // アクティブスタイルの切り替え
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('bg-opacity-100'));
                    btn.classList.add('bg-opacity-100');
                    fetchAndRenderData(); // フィルタリングを適用して再描画
                };
            });
            
            // 報告ボタンのクリックイベント (モーダル表示)
            document.querySelectorAll('.report-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation(); // 詳細パネルの展開を防ぐ
                    const mobName = btn.dataset.mobName;
                    const mobRank = btn.dataset.mobRank;
                    
                    document.getElementById('modal-mob-name').textContent = `${mobRank} ${mobName} の討伐報告`;
                    document.getElementById('submit-report').dataset.mobName = mobName;
                    document.getElementById('submit-report').dataset.mobRank = mobRank;
                    document.getElementById('report-modal').classList.remove('hidden');
                    document.getElementById('report-modal').classList.add('flex');
                };
            });

            // 詳細パネルの展開/格納イベント
            document.querySelectorAll('.fixed-content').forEach(content => {
                content.onclick = (e) => {
                    // 報告ボタンがクリックされた場合は処理しない（バブリングを防ぐ）
                    if (e.target.closest('.report-btn')) return;
                    
                    const details = content.parentElement.querySelector('.mob-details');
                    if (details) {
                        details.classList.toggle('open');
                    }
                };
            });

            // モーダルキャンセルボタン
            document.getElementById('cancel-report').onclick = () => {
                document.getElementById('report-modal').classList.add('hidden');
                document.getElementById('report-modal').classList.remove('flex');
            };

            // モーダル送信ボタン
            document.getElementById('submit-report').onclick = async (e) => {
                const button = e.target;
                const mobName = button.dataset.mobName;
                const mobRank = button.dataset.mobRank;
                const memo = document.getElementById('report-memo').value;
                const statusElement = document.getElementById('report-status');
                
                statusElement.classList.remove('hidden');
                statusElement.textContent = '送信中...';
                button.disabled = true;

                const payload = {
                    action: "addRecord",
                    モブ名: mobName,
                    ランク: mobRank,
                    報告者UUID: userId,
                    メモ: memo
                };

                try {
                    const response = await fetch(`${GAS_ENDPOINT}?action=addRecord`, {
                        method: 'POST',
                        mode: 'cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();

                    if (result.status === "success") {
                        statusElement.textContent = '報告が完了しました！';
                        statusElement.classList.add('text-green-500');
                        statusElement.classList.remove('text-red-500');
                        
                        // データを再取得して画面を更新
                        setTimeout(() => {
                            document.getElementById('report-modal').classList.add('hidden');
                            document.getElementById('report-modal').classList.remove('flex');
                            fetchAndRenderData();
                            button.disabled = false;
                        }, 1500);
                    } else {
                        throw new Error(result.message);
                    }

                } catch (error) {
                    console.error("報告エラー:", error);
                    statusElement.textContent = `報告エラー: ${error.message}`;
                    statusElement.classList.add('text-red-500');
                    statusElement.classList.remove('text-green-500');
                    button.disabled = false;
                }
            };
        }

        // --- 初期化 ---

        /**
         * サイトの初期化処理
         */
        function initializeApp() {
            // 報告者UUIDの生成または取得
            userId = localStorage.getItem('user_uuid');
            if (!userId) {
                userId = crypto.randomUUID();
                localStorage.setItem('user_uuid', userId);
            }

            // 初期表示
            fetchAndRenderData();

            // 5分ごとにデータを更新
            setInterval(fetchAndRenderData, 5 * 60 * 1000); 
        }

        // ページロード時に初期化を実行
        initializeApp();

    </script>
</body>
</html>
