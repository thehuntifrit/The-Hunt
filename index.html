<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hunt</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-dark': '#1e293b', // Slate-800
                        'secondary-dark': '#334155', // Slate-700
                        'accent-green': '#a7f3d0', // Emerald-200 (パステル調の黄緑)
                        'accent-red': '#f87171', // Red-400 for errors/warnings
                        'rank-s': '#3b82f6', // Blue-500
                        'rank-a': '#22c55e', // Green-500
                        'rank-f': '#f59e0b', // Amber-500
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* カスタムスタイル */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate-900 (ダークモード背景) */
            color: #f1f5f9; /* Slate-100 */
        }

        .container {
            max-width: 100%;
            /* PC: 3カラム（約512px x 3 + マージン） */
            /* タブレット: 1カラム */
        }

        /* モブカードの基本スタイル */
        .mob-card {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            overflow: hidden;
            background-color: #1e293b; /* primary-dark */
        }

        .mob-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
        }

        /* 進行度ゲージ（グラデーション背景） */
        .progress-bar-bg {
            background-color: #334155; /* secondary-dark */
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--tw-accent-green);
            transition: width 0.5s ease-out;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        .progress-content {
            position: relative;
            z-index: 20;
        }

        /* 文字のアウトライン風シャドウ (藍色: #4f46e5) */
        .text-outline {
            text-shadow: 
                1px 1px 0 #4f46e5, 
                -1px -1px 0 #4f46e5, 
                1px -1px 0 #4f46e5, 
                -1px 1px 0 #4f46e5;
        }

        /* マップのスタイル */
        .map-container {
            position: relative;
            width: 500px;
            height: 500px;
            margin: 0 auto;
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .map-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* POP地点の円 */
        .pop-point {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 2px solid #0f172a;
        }
        
        /* 状態別カラー */
        .pop-candidate { background-color: #22c55e; } /* 緑: POP候補地 */
        .pop-checked { background-color: #dc2626; } /* 赤: POPしなかった（チェック済み） */

        /* レスポンシブグリッド */
        .mob-grid {
            display: grid;
            gap: 1rem;
            /* スマホ: 1カラム */
            grid-template-columns: repeat(1, minmax(0, 1fr));
        }

        @media (min-width: 768px) {
            /* タブレット以上: 1カラム (横幅いっぱい) */
            .mob-grid {
                grid-template-columns: repeat(1, minmax(0, 1fr));
            }
        }

        @media (min-width: 1440px) {
            /* PC (Full HD最大化): 3カラム */
            .mob-grid {
                grid-template-columns: repeat(3, minmax(0, 512px));
                justify-content: center;
            }
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <div id="app" class="container mx-auto">
        <h1 class="text-4xl font-extrabold text-center mb-2 text-white">The Hunt</h1>
        <p id="app-description" class="text-center text-slate-400 mb-6">
            FF14のモブハントの討伐報告とPOP予想時刻を追跡します。
        </p>

        <!-- メンテナンス情報表示エリア -->
        <div id="maintenance-info" class="text-center mb-6 p-3 rounded-lg bg-red-900/50 hidden">
            <p class="text-lg font-semibold text-accent-red"></p>
        </div>

        <!-- タブナビゲーション -->
        <div class="flex justify-center space-x-2 mb-6 p-1 bg-primary-dark rounded-lg shadow-lg">
            <!-- 初期状態のボタンには非アクティブ時のクラスを設定します -->
            <button class="tab-button px-4 py-2 rounded-md font-medium text-slate-300 hover:bg-slate-700/50 transition" data-rank="all">全て</button>
            <button class="tab-button px-4 py-2 rounded-md font-medium text-slate-300 hover:bg-slate-700/50 transition" data-rank="S">Sランク</button>
            <button class="tab-button px-4 py-2 rounded-md font-medium text-slate-300 hover:bg-slate-700/50 transition" data-rank="A">Aランク</button>
            <button class="tab-button px-4 py-2 rounded-md font-medium text-slate-300 hover:bg-slate-700/50 transition" data-rank="FATE">FATE</button>
        </div>

        <!-- モブリスト -->
        <div id="mob-list" class="mob-grid">
            <!-- モブカードがここに動的に挿入されます -->
            <div class="text-center p-4 text-slate-400">データを読み込み中です...</div>
        </div>

        <!-- 討伐報告モーダル -->
        <div id="report-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center p-4 z-50">
            <div class="bg-secondary-dark p-6 rounded-xl shadow-2xl w-full max-w-md">
                <h2 class="text-2xl font-bold mb-4 text-white" id="modal-mob-name"></h2>
                <p class="mb-4 text-slate-300">モブを討伐した日時と場所を報告してください。</p>

                <div class="mb-4">
                    <label for="world-select" class="block text-sm font-medium text-slate-400 mb-1">討伐ワールド</label>
                    <select id="world-select" class="w-full p-2 rounded-md bg-primary-dark border border-slate-600 text-white focus:ring-blue-500 focus:border-blue-500">
                        <!-- ワールドリストがここに挿入されます -->
                    </select>
                </div>

                <div class="flex justify-end space-x-3">
                    <button id="close-modal-btn" class="px-4 py-2 bg-slate-600 text-white rounded-lg hover:bg-slate-500 transition">キャンセル</button>
                    <button id="submit-report-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-500 transition">討伐報告</button>
                </div>
                <p id="report-message" class="mt-4 text-sm text-center hidden"></p>
            </div>
        </div>
    </div>

    <script>
        // --- 設定定数 ---
        // TODO: デプロイしたGASのWeb App URLに置き換えてください
        const GAS_API_URL = 'https://script.google.com/macros/s/AKfycbxyutpOIZYI9Ce51s4vawk6S460QgM4wYcaLFJKUBi00_LKhNXT9-6N0n178KdoXkP7wg/exec'; 
        // 静的モブデータファイル
        const STATIC_DATA_URL = './mob_data.json';
        // モブカードのアニメーション時間 (CSSのtransitionと一致させる)
        const CARD_SLIDE_DURATION = 200; 

        // --- グローバル変数 ---
        let globalMobConfig = [];
        let globalLocationDef = [];
        let globalHuntList = [];
        let globalLocationState = [];
        let globalMaintenanceInfo = null;
        let globalReporterUUID = null;
        let currentFilter = 'all';
        let currentMobToReport = null; // 報告対象のモブ

        // --- ユーティリティ関数 ---

        /**
         * 匿名報告者ID (UUID) の取得または生成
         * @returns {string} 報告者ID
         */
        function getReporterUUID() {
            let uuid = localStorage.getItem('reporterUUID');
            if (!uuid) {
                // UUID (v4) を生成
                uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
                localStorage.setItem('reporterUUID', uuid);
            }
            return uuid;
        }

        /**
         * 日本時間 (JST) のフォーマット (例: 10/04 18:30:00)
         * @param {Date} date - UTC Dateオブジェクト
         * @returns {string} JST文字列
         */
        function formatTimeToJST(date) {
            const options = { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit', 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit', 
                hour12: false,
                timeZone: 'Asia/Tokyo' // JST
            };
            return new Intl.DateTimeFormat('ja-JP', options).format(date);
        }

        /**
         * 秒数を HH:MM:SS 形式に変換
         * @param {number} totalSeconds - 秒数
         * @returns {string} HH:MM:SS
         */
        function secondsToHms(totalSeconds) {
            const h = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
            const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
            const s = String(Math.floor(totalSeconds % 60)).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }
        
        // --- ET (エオルゼア時間) 関連のユーティリティ関数 ---

        // ETとLTの比率: LT 70秒 = ET 3600秒 (1時間)
        const ET_RATIO = 3600 / 70; 
        const MS_PER_ET_HOUR = 70 * 1000; // 70秒 = 1 ET時間 (ミリ秒)

        /**
         * 現実時間 (Local Time: LT) からエオルゼア時間 (ET) のDateオブジェクトを計算する
         * @param {Date} ltDate - 現実時間（Dateオブジェクト）
         * @returns {Date} エオルゼア時間（ET）のDateオブジェクト
         */
        function calculateET(ltDate) {
            // 基準時刻: 2010年1月1日 00:00:00 UTC (ETの計算基準)
            const BASE_LT = new Date('2010-01-01T00:00:00Z').getTime();
            
            // 現在のLT（UTCミリ秒）
            const currentLT = ltDate.getTime();
            
            // 基準時からの経過時間（ミリ秒）
            const elapsedLT = currentLT - BASE_LT;
            
            // ETでの経過時間（ミリ秒）
            const elapsedET = elapsedLT * ET_RATIO;
            
            // ETのDateオブジェクトを計算（2010年1月1日 00:00:00を基準としたET時間）
            const etDate = new Date(BASE_LT + elapsedET);
            
            return etDate;
        }

        /**
         * ETのDateオブジェクトから、ETの時刻（時:分:秒）を取得する
         * @param {Date} etDate - エオルゼア時間（ET）のDateオブジェクト
         * @returns {string} ET時刻文字列 (例: 19:30)
         */
        function getETTime(etDate) {
            // ETは常にUTCとして扱う
            const etHour = String(etDate.getUTCHours()).padStart(2, '0');
            const etMinute = String(etDate.getUTCMinutes()).padStart(2, '0');
            return `${etHour}:${etMinute}`;
        }

        /**
         * モブ設定の「時間条件」文字列を満たしているか判定する（例: "19:00-21:59"）
         */
        function isETConditionMet(conditionString, etHour) {
            // 実際に計算で使う際は、もう少し複雑なロジックが必要です
            return true; 
        }
        
        // --- データ取得ロジック ---

        /**
         * 静的データ (mob_data.json) を取得
         */
        async function fetchStaticData() {
            try {
                const response = await fetch(STATIC_DATA_URL);
                if (!response.ok) {
                    throw new Error(`Failed to fetch static data: ${response.statusText}`);
                }
                const data = await response.json();
                
                globalMobConfig = data.mobConfig || [];
                globalLocationDef = data.locationDef || [];
                
                console.log('Static data loaded successfully.');
            } catch (error) {
                console.error('Error fetching static data:', error);
                document.getElementById('mob-list').innerHTML = '<div class="text-center p-4 text-accent-red">設定ファイルの読み込みに失敗しました。ファイル名 mob_data.json を確認してください。</div>';
            }
        }

        /**
         * 動的データ (Hunt_Data, Location_State, Maintenance) をGASから取得
         */
        async function fetchDynamicData() {
            try {
                // Exponential Backoff を適用
                let result = null;
                for (let i = 0; i < 3; i++) { // 最大3回のリトライ
                    const response = await fetch(GAS_API_URL + '?mode=getdata');
                    if (response.ok) {
                        result = await response.json();
                        break;
                    }
                    if (i < 2) {
                        await new Promise(resolve => setTimeout(resolve, (2 ** i) * 1000)); // 1s, 2s の待機
                    } else {
                        throw new Error(`GAS API fetch failed after multiple retries: ${response.statusText}`);
                    }
                }

                if (result && result.status === 'success') {
                    globalHuntList = result.huntList || [];
                    globalLocationState = result.locationState || [];
                    globalMaintenanceInfo = result.maintenance;
                    return true;
                } else if (result) {
                    console.error('GAS API Error:', result.message);
                    return false;
                }
                return false;
            } catch (error) {
                console.error('Error fetching dynamic data from GAS:', error);
                return false;
            }
        }

        // --- メイン処理 ---

        /**
         * アプリケーションを初期化し、データを取得して表示
         * @param {boolean} fetchStatic - 静的データも取得するかどうか
         */
        async function initApp(fetchStatic = true) {
            if (fetchStatic) {
                await fetchStaticData();
            }
            const success = await fetchDynamicData();
            
            if (success) {
                globalReporterUUID = getReporterUUID();
                renderMaintenanceInfo();
                renderMobList();
                
                // 30秒ごとに動的データを更新
                setTimeout(() => initApp(false), 30000); // 静的データは再取得しない
            } else {
                // 初回ロード失敗時のみエラー表示
                if (fetchStatic) {
                    document.getElementById('mob-list').innerHTML = '<div class="text-center p-4 text-accent-red">動的データ（討伐ログ等）の取得に失敗しました。GASのURL設定またはデプロイを確認してください。</div>';
                }
            }
        }

        /**
         * メンテナンス情報の表示
         */
        function renderMaintenanceInfo() {
            const infoDiv = document.getElementById('maintenance-info');
            const infoText = infoDiv.querySelector('p');

            if (globalMaintenanceInfo && globalMaintenanceInfo.trim() !== '最新のメンテナンス記事が見つかりませんでした。') {
                infoText.textContent = globalMaintenanceInfo;
                infoDiv.classList.remove('hidden');
            } else {
                infoDiv.classList.add('hidden');
            }
        }

        /**
         * 全モブのリストをレンダリング
         */
        function renderMobList() {
            const mobListContainer = document.getElementById('mob-list');
            
            // 1. 各モブの最新討伐情報を付加
            const mobsWithInfo = globalMobConfig.map(mob => {
                const lastKills = globalHuntList
                    .filter(h => h.mobName === mob['モブ名'])
                    .sort((a, b) => new Date(b.killTime) - new Date(a.killTime));
                
                mob.lastKill = lastKills[0] || null;
                
                // 経過時間とパーセンテージの計算
                const now = Date.now();
                const repopIntervalMs = mob['リポップ間隔 (秒)'] * 1000;
                
                if (mob.lastKill) {
                    const killTimeMs = new Date(mob.lastKill.killTime).getTime();
                    const elapsedMs = now - killTimeMs;
                    mob.elapsedPercent = Math.min(100, (elapsedMs / repopIntervalMs) * 100);
                    mob.nextPopTime = new Date(killTimeMs + repopIntervalMs);
                } else {
                    // 初回またはデータがない場合
                    mob.elapsedPercent = 0;
                    mob.nextPopTime = null;
                }

                // マップアイコンの表示判定
                mob.hasMap = globalLocationDef.some(loc => loc.mobName === mob['モブ名']);
                
                // 日本語キーを安全に参照
                mob.mapFileName = mob['マップ画像 (ファイル名)'];

                return mob;
            });
            
            // 2. 経過時間%で降順ソート
            mobsWithInfo.sort((a, b) => b.elapsedPercent - a.elapsedPercent);
            
            // 3. フィルタリング
            const filteredMobs = mobsWithInfo.filter(mob => 
                currentFilter === 'all' || mob['ランク'] === currentFilter
            );

            // 4. HTML生成
            mobListContainer.innerHTML = '';
            if (filteredMobs.length === 0) {
                 mobListContainer.innerHTML = '<div class="text-center p-4 text-slate-400">該当するモブがいません。</div>';
            } else {
                filteredMobs.forEach(mob => {
                    const cardHtml = createMobCard(mob);
                    mobListContainer.insertAdjacentHTML('beforeend', cardHtml);
                });
            }
            
            // 5. イベントリスナーの再設定
            setupEventListeners();
        }

        /**
         * 個別のモブカードHTMLを生成
         * @param {Object} mob - モブデータと計算結果を含むオブジェクト
         */
        function createMobCard(mob) {
            const rankColor = {
                'S': 'bg-rank-s',
                'A': 'bg-rank-a',
                'FATE': 'bg-rank-f',
                'なし': 'bg-slate-500'
            }[mob['ランク']] || 'bg-slate-500';

            const nextPopDisplay = mob.nextPopTime 
                ? formatTimeToJST(mob.nextPopTime)
                : '不明 (初報求む)';

            const elapsedDuration = mob.lastKill
                ? secondsToHms(Math.max(0, (Date.now() - new Date(mob.lastKill.killTime).getTime()) / 1000))
                : '---';

            const lastKillDisplay = mob.lastKill 
                ? formatTimeToJST(new Date(mob.lastKill.killTime)) 
                : '---';

            const mapIcon = mob.hasMap ? ' 🗺️' : '';
            
            // マップ表示エリアのID
            const mapAreaId = `map-area-${mob['モブ名'].replace(/\s/g, '-')}`;

            return `
                <div class="mob-card rounded-xl shadow-xl transition-all duration-300" data-mob-name="${mob['モブ名']}" data-rank="${mob['ランク']}">
                    <!-- 上部コンテンツエリア -->
                    <div class="progress-bar-bg p-4 rounded-t-xl overflow-hidden relative" data-percent="${mob.elapsedPercent}">
                        <div class="progress-fill bg-accent-green" style="width: ${mob.elapsedPercent}%;"></div>
                        <div class="progress-content relative flex flex-col space-y-2">
                            <div class="flex justify-between items-start">
                                <!-- モンスター名, エリア名 -->
                                <div class="flex flex-col">
                                    <div class="flex items-center space-x-2">
                                        <span class="text-2xl font-bold text-outline text-white">${mob['モブ名']}${mapIcon}</span>
                                        <!-- マップアイコンホバー表示 -->
                                        ${mob.hasMap ? `<span class="map-icon text-lg cursor-pointer" data-mob-name="${mob['モブ名']}" title="POP地点マップを表示">🗺️</span>` : ''}
                                    </div>
                                    <span class="text-lg font-medium text-slate-300">${mob['エリア名']}</span>
                                </div>
                                <!-- ランクと報告ボタン -->
                                <div class="flex flex-col items-end space-y-1">
                                    <span class="px-2 py-1 text-sm font-semibold rounded-full text-white ${rankColor}">${mob['ランク']}</span>
                                    <button class="report-btn px-3 py-1 text-sm bg-indigo-600 text-white rounded-lg hover:bg-indigo-500 transition">報告</button>
                                </div>
                            </div>
                            <!-- 次回POP時間 (経過%) -->
                            <div class="text-sm font-semibold text-white">
                                <p>次回POP予想: ${nextPopDisplay}</p>
                                <p>経過: ${elapsedDuration} (${mob.elapsedPercent.toFixed(1)}%)</p>
                            </div>
                        </div>
                    </div>

                    <!-- 詳細ドロップダウンエリア -->
                    <div class="detail-content overflow-hidden max-h-0 transition-all duration-500 bg-secondary-dark rounded-b-xl">
                        <div class="p-4 space-y-3">
                            <!-- 前回の討伐時間 -->
                            <div>
                                <p class="text-sm text-slate-400">前回の討伐時間 (JST):</p>
                                <p class="text-lg font-semibold text-white">${lastKillDisplay}</p>
                            </div>
                            <!-- POPさせる条件の説明 -->
                            <div>
                                <p class="text-sm text-slate-400">POP条件:</p>
                                <p class="text-lg font-semibold text-white">${mob['POP条件'] || 'なし'}</p>
                                <p class="text-sm text-slate-300">時間条件: ${mob['時間条件'] || '常時'}</p>
                                <p class="text-sm text-slate-300">天候条件: ${mob['天候条件'] || '全て'}</p>
                            </div>

                            <!-- 座標記録用のMAP (ここにマップが描画されます) -->
                            <div class="map-section">
                                <p class="text-sm text-slate-400 mb-2">POP地点トラッカー:</p>
                                <div id="${mapAreaId}" class="map-container hidden">
                                    <!-- マップ画像とPOP点がJSによって挿入されます -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * マップコンテナに画像とPOP地点を動的に描画
         * @param {string} mobName - モブ名
         */
        function renderMap(mobName) {
            const mob = globalMobConfig.find(m => m['モブ名'] === mobName);
            const mapContainer = document.getElementById(`map-area-${mobName.replace(/\s/g, '-')}`);
            
            // 日本語キーを安全に参照
            const mapFileName = mob ? mob['マップ画像 (ファイル名)'] : null;

            if (!mob || !mapFileName) {
                mapContainer.innerHTML = '<p class="text-slate-500 text-center py-4">マップ画像が設定されていません。</p>';
                mapContainer.classList.remove('hidden');
                return;
            }

            // マップ画像パスは 'Picture' フォルダを使用
            const imagePath = `./Picture/${mapFileName}`;

            // マップの定義済み座標を取得
            const definedLocations = globalLocationDef.filter(loc => loc.mobName === mobName);
            
            // 現在のチェック済み状態を取得 (Location_State)
            const checkedStates = globalLocationState
                .filter(state => state.mobName === mobName)
                .map(state => state.checkedLocationId);

            let mapHtml = `<img src="${imagePath}" class="map-image" onerror="this.onerror=null; this.src='https://placehold.co/500x500/1e293b/94a3b8?text=Map+Not+Found'" alt="${mob['エリア名']} Map">`;
            
            definedLocations.forEach(loc => {
                const isChecked = checkedStates.includes(loc.locationId);
                // チェック済みなら赤 (POPしなかった)
                const stateClass = isChecked ? 'pop-checked' : 'pop-candidate'; 
                
                // 座標をパーセンテージで計算 (画像サイズ 500x500 を仮定)
                const xPercent = (loc.coordX / 500) * 100;
                const yPercent = (loc.coordY / 500) * 100;

                mapHtml += `
                    <div class="pop-point ${stateClass}" 
                         style="left: ${xPercent}%; top: ${yPercent}%; transform: translate(-50%, -50%);"
                         data-mob-name="${mobName}"
                         data-location-id="${loc.locationId}"
                         data-checked="${isChecked}">
                    </div>
                `;
            });

            mapContainer.innerHTML = mapHtml;
            mapContainer.classList.remove('hidden');
            
            // POP地点のクリックイベント設定
            mapContainer.querySelectorAll('.pop-point').forEach(point => {
                point.addEventListener('click', handlePopPointClick);
            });
        }


        /**
         * POP地点クリック時の処理（チェックイン）
         */
        function handlePopPointClick(event) {
            const point = event.currentTarget;
            const mobName = point.getAttribute('data-mob-name');
            const locationId = point.getAttribute('data-location-id');
            const isChecked = point.getAttribute('data-checked') === 'true';

            if (isChecked) {
                console.log(`Location ${locationId} for ${mobName} is already checked. Skipping submission.`);
                return;
            }
            
            // カスタムモーダル UI を使用する代わりに、今回はコンソールにメッセージを出力して処理を続行します
            console.log(`${mobName}の座標 ${locationId} を「POPしなかった場所」として記録を試みます。`);

            // GASへチェックインデータを送信
            sendLocationState({
                mobName: mobName,
                locationId: locationId,
                reporterId: globalReporterUUID
            });
        }

        /**
         * 討伐報告または座標チェックインデータをGASに送信
         * @param {Object} data - 送信するデータ
         * @param {string} type - 'kill' または 'location'
         */
        async function sendDataToGas(data, type) {
            const url = GAS_API_URL + '?mode=post&type=' + type;
            try {
                // Exponential Backoff を適用
                let result = null;
                for (let i = 0; i < 3; i++) {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    
                    if (response.ok) {
                        result = await response.json();
                        break;
                    }
                    if (i < 2) {
                        await new Promise(resolve => setTimeout(resolve, (2 ** i) * 1000));
                    } else {
                         throw new Error(`GAS API post failed after multiple retries: ${response.statusText}`);
                    }
                }
                
                if (result && result.status === 'success') {
                    console.log(`${type} report success.`);
                    // 成功したらデータを再取得してリストを更新
                    await fetchDynamicData();
                    renderMobList();
                    return true;
                } else if (result) {
                    console.error(`${type} report failed:`, result.message);
                    return false;
                }
                return false;
            } catch (error) {
                console.error(`Error sending ${type} data to GAS:`, error);
                return false;
            }
        }

        /**
         * 座標チェックインデータをGASに送信
         */
        function sendLocationState(data) {
            // ステータスを 'checked' で送信 (GAS側で Location_State に書き込み)
            sendDataToGas(data, 'location'); 
        }

        /**
         * 討伐報告データをGASに送信
         */
        async function submitKillReport(mobName, world) {
            const mob = globalMobConfig.find(m => m['モブ名'] === mobName);
            if (!mob) return false;

            const killReportData = {
                mobName: mobName,
                mobRank: mob['ランク'],
                area: mob['エリア名'],
                world: world,
                reporterId: globalReporterUUID,
            };

            const success = await sendDataToGas(killReportData, 'kill');

            const messageEl = document.getElementById('report-message');
            messageEl.classList.remove('hidden');

            if (success) {
                messageEl.textContent = `${mobName}の討伐を報告しました。マップ状態をリセットしました。`;
                messageEl.classList.add('text-green-400');
                messageEl.classList.remove('text-accent-red');
            } else {
                messageEl.textContent = '報告に失敗しました。GASのログを確認してください。';
                messageEl.classList.remove('text-green-400');
                messageEl.classList.add('text-accent-red');
            }
            
            // モーダルが閉じたらメッセージはリセット
            return success;
        }

        /**
         * タブボタンのCSSクラスを切り替える
         * @param {HTMLElement} button - 対象のボタン要素
         * @param {boolean} isActive - アクティブ状態かどうか
         */
        function toggleActiveClass(button, isActive) {
            const activeClasses = ['bg-accent-green', 'text-primary-dark', 'shadow-inner'];
            const inactiveClasses = ['text-slate-300', 'hover:bg-slate-700/50'];

            if (isActive) {
                button.classList.add(...activeClasses);
                button.classList.remove(...inactiveClasses);
            } else {
                button.classList.remove(...activeClasses);
                button.classList.add(...inactiveClasses);
            }
        }

        // --- イベントハンドラ設定 ---
        function setupEventListeners() {
            // 1. カードクリック時の詳細表示/非表示
            document.querySelectorAll('.mob-card').forEach(card => {
                const detailContent = card.querySelector('.detail-content');
                const mobName = card.getAttribute('data-mob-name');
                const mapArea = card.querySelector(`#map-area-${mobName.replace(/\s/g, '-')}`);

                // 詳細コンテンツの max-height をリセット
                detailContent.style.maxHeight = '0';
                mapArea.classList.add('hidden');

                card.addEventListener('click', function(e) {
                    // 報告ボタンやマップアイコン、POP地点がクリックされた場合は処理をスキップ
                    if (e.target.closest('.report-btn') || e.target.closest('.map-icon') || e.target.closest('.pop-point')) {
                        return;
                    }

                    const isExpanded = detailContent.classList.contains('is-expanded');
                    
                    if (isExpanded) {
                        detailContent.style.maxHeight = '0';
                        detailContent.classList.remove('is-expanded');
                        mapArea.classList.add('hidden');
                    } else {
                        // マップのレンダリング
                        renderMap(mobName);
                        
                        // 最大高さを計算して展開 (scrollHeightを使う)
                        // マップが展開される前に計算すると高さが足りなくなるため、少し遅延させるか、scrollHeightを正しく取得する必要があります。
                        // 今回は mapArea の height (500px) + padding/margin を概算して多めに設定します
                        const requiredHeight = detailContent.scrollHeight + 550; // スクロールハイト + マップの最大高さ
                        detailContent.style.maxHeight = requiredHeight + "px";
                        detailContent.classList.add('is-expanded');
                    }
                });
            });

            // 2. 報告ボタンクリック時のモーダル表示
            document.querySelectorAll('.report-btn').forEach(btn => {
                btn.onclick = function(e) {
                    e.stopPropagation(); // カードクリックイベントの伝播を停止
                    const card = e.target.closest('.mob-card');
                    currentMobToReport = card.getAttribute('data-mob-name');
                    document.getElementById('modal-mob-name').textContent = `${currentMobToReport} の討伐報告`;
                    document.getElementById('report-modal').classList.remove('hidden');
                    document.getElementById('report-modal').classList.add('flex');
                    document.getElementById('report-message').classList.add('hidden');
                    
                    // ワールドリストの生成 (ここではダミー。必要に応じて変更してください)
                    const worldSelect = document.getElementById('world-select');
                    worldSelect.innerHTML = `
                        <option value="Elemental">Elemental</option>
                        <option value="Gaia">Gaia</option>
                        <option value="Mana" selected>Mana</option>
                        <option value="Meteor">Meteor</option>
                    `;
                };
            });

            // 3. フィルターボタン
            document.querySelectorAll('.tab-button').forEach(btn => {
                const rank = btn.getAttribute('data-rank');

                // 初期状態・更新後のアクティブ状態の設定
                toggleActiveClass(btn, rank === currentFilter);

                btn.onclick = function() {
                    if (rank === currentFilter) return; // すでに選択されている場合は何もしない
                    
                    currentFilter = rank;
                    
                    // 全ボタンのアクティブ状態を更新
                    document.querySelectorAll('.tab-button').forEach(b => {
                        toggleActiveClass(b, b === btn);
                    });
                    
                    // モブリストを再描画
                    renderMobList();
                };
            });

            // 4. モーダル操作
            document.getElementById('close-modal-btn').onclick = () => {
                document.getElementById('report-modal').classList.add('hidden');
                document.getElementById('report-modal').classList.remove('flex');
                currentMobToReport = null;
            };

            document.getElementById('submit-report-btn').onclick = async () => {
                const world = document.getElementById('world-select').value;
                const success = await submitKillReport(currentMobToReport, world);
                
                // 成功したら自動的にモーダルを閉じる
                if (success) {
                     setTimeout(() => {
                        document.getElementById('report-modal').classList.add('hidden');
                        document.getElementById('report-modal').classList.remove('flex');
                     }, 1500);
                }
            };
        }

        // 初期化実行
        window.onload = function() {
            initApp();
        };

    </script>
</body>
</html>
