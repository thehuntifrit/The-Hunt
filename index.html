<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hunt Tracker</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* 基本的なダークモード設定 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* ダークブルー */
            color: #ffffff; /* 白文字 */
        }
        
        /* コンテンツ幅の制御とセンタリング */
        .container {
            max-width: 1536px; /* 2XL相当 */
            margin-left: auto;
            margin-right: auto;
            padding: 0 1rem;
        }

        /* カスタムグリッド（レスポンシブ対応） */
        .mob-grid {
            /* スマホ (デフォルト) */
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }
        /* PC (lg以上) - 3カラムで配置 */
        @media (min-width: 1024px) {
            .mob-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        /* タブレット (md以上) - 1カラム幅512pxを中央寄せ */
        @media (min-width: 768px) and (max-width: 1023px) {
            .mob-grid {
                grid-template-columns: 1fr;
            }
            .mob-grid > div {
                max-width: 512px;
                margin-left: auto;
                margin-right: auto;
            }
        }

        /* ======================================================= */
        /* カード構造 */
        /* ======================================================= */
        .mob-card-wrapper {
            background-color: #2d3748; /* カード背景色 (濃いグレー) */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s, transform 0.2s;
            position: relative; /* 🚨 詳細パネルの絶対配置の基準 */
            z-index: 10; 
            overflow: visible; /* 展開された詳細パネルが見えるように */
        }

        .mob-card-wrapper:hover {
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
        }

        /* カードのクリック可能部分 (ヘッダー) */
        .mob-card-header {
            position: relative;
            z-index: 20; 
            cursor: pointer;
            border-radius: 0.5rem; 
            overflow: hidden; 
        }

        /* 展開時にヘッダーの下側の角丸を解除し、一体感を持たせる */
        .mob-card-wrapper .mob-card-header.is-expanded {
             border-bottom-left-radius: 0;
             border-bottom-right-radius: 0;
        }

        /* 経過時間ゲージのベース */
        .progress-bar {
            height: 100%;
            background-color: #f6e05e; 
            transition: width 0.5s ease-out;
        }

        /* テキストのアウトライン風シャドウ */
        .text-outline {
            text-shadow: 
                -1px -1px 0 #3182ce,  
                 1px -1px 0 #3182ce,
                -1px  1px 0 #3182ce,
                 1px  1px 0 #3182ce;
        }

        /* タブのアクティブスタイル */
        .tab-active {
            background-color: #68d391 !important; /* パステル黄緑 */
            color: #1a202c !important; /* 濃い文字色 */
            font-weight: 700;
        }

        /* マップオーバーレイ */
        .map-container {
            position: relative;
            max-width: 500px; 
            height: 500px; 
            margin: 0 auto;
        }
        
        .map-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            user-select: none;
        }

        /* POP地点マーカー */
        .pop-point {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid #ffffff;
            cursor: pointer;
            opacity: 0.85;
            transition: transform 0.1s;
        }
        .pop-point:hover {
            transform: scale(1.3);
            opacity: 1;
        }

        /* 状態別カラー */
        .pop-candidate {
            background-color: #48bb78; /* Tailwind green-500 */
        }
        .pop-checked {
            background-color: #e53e3e; /* Tailwind red-600 */
        }

        /* メンテナンス情報 */
        #maintenance-message {
            color: #fc8181; 
            font-weight: 700;
            padding: 0.5rem;
            margin-top: 0.5rem;
            text-align: center;
        }

        /* ======================================================= */
        /* 🚨 最終修正: 詳細情報 (オーバーレイ/絶対配置) */
        /* 🚨 背景色を明るくし、枠線を削除 */
        /* ======================================================= */
        .detail-accordion {
            position: absolute; /* 絶対配置: 下の要素を押し下げない */
            top: 100%; /* ヘッダーの真下から展開 */
            left: 0;
            right: 0;
            z-index: 30; /* カードより前面 (オーバーレイ) */
            
            /* 🚨 色の変更: カード背景 #2d3748 より少し明るい #364152 を使用 */
            background-color: #364152; 
            
            /* 🚨 枠線の削除 */
            border: none; 
            border-radius: 0 0 0.5rem 0.5rem; /* 下側の角丸を維持 */

            /* 非表示状態 */
            max-height: 0; /* max-heightでスライドダウンを制御 */
            overflow: hidden; 
            opacity: 0;
            padding: 0 1rem; 
            
            /* アニメーション */
            transition: max-height 0.4s ease-out, opacity 0.4s ease-out, padding-top 0.4s ease-out, padding-bottom 0.4s ease-out;
        }

        .detail-accordion.is-open {
            /* 表示状態: 下の要素を押し下げない (オーバーレイ) */
            max-height: 2000px; /* 適切な最大高さを設定 */
            padding-top: 1rem;
            padding-bottom: 1rem;
            opacity: 1;
        }

        /* A/FATEランクで中身が空の場合のパディング調整 */
        .detail-accordion.is-empty.is-open {
             padding-top: 0.5rem; 
             padding-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    
    <!-- FIXED HEADER START: タイトル、説明、タブを固定 -->
    <div id="fixed-header" class="fixed top-0 left-0 right-0 z-20 bg-[#1a202c] shadow-2xl pb-4">
        <div class="container">
            <!-- サイトタイトルと説明 -->
            <header class="text-center pt-8 mb-4">
                <h1 class="text-5xl font-extrabold mb-2 text-yellow-400">The Hunt Tracker</h1>
                <p id="site-description" class="text-gray-300">
                    エオルゼアのモブハント情報をリアルタイムで追跡し、POP地点を共有するためのツールです。
                    <br>
                    <span class="text-sm text-yellow-400">現在、Ifritワールド専用で運用中。</span>
                </p>
                <!-- メンテナンス情報表示エリア -->
                <p id="maintenance-message" class="hidden"></p>
            </header>
            
            <!-- 読み込み中/エラーメッセージ -->
            <div id="loading-status" class="text-center text-xl p-2 rounded-lg bg-yellow-900/50 mx-4">
                データを読み込み中です...
            </div>

            <!-- タブフィルター (grid-cols-4でサイズ統一) -->
            <div id="filter-tabs" class="grid grid-cols-4 gap-2 mt-4 mx-4 p-1 bg-gray-700 rounded-lg">
                <!-- タブはJavaScriptで生成されます -->
            </div>
        </div>
    </div>
    <!-- FIXED HEADER END -->

    <!-- コンテンツ本体 (ヘッダーの高さ分、上部にパディングを確保) -->
    <div class="container pt-[250px] lg:pt-[220px] pb-40">
        <!-- モブ一覧コンテナ -->
        <div id="mob-list-container" class="mob-grid">
            <!-- モブカードはJavaScriptでここに挿入されます -->
        </div>
    </div>

    <!-- 討伐報告モーダル (日時入力) -->
    <div id="report-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-gray-800 p-6 rounded-xl w-11/12 max-w-sm">
            <h2 id="modal-title" class="text-2xl font-bold mb-4 text-white">討伐報告</h2>
            <p class="text-gray-300 mb-4">討伐日時を正確に入力してください。デフォルトで現在のJSTが設定されています。</p>
            
            <input type="hidden" id="report-mob-name">
            <input type="hidden" id="report-mob-rank">
            <input type="hidden" id="report-mob-area">

            <!-- 日時入力フィールド -->
            <label for="kill-time-input" class="block text-sm font-medium text-gray-400 mb-1">討伐日時 (JST)</label>
            <input type="datetime-local" id="kill-time-input" 
                   class="w-full p-2 mb-4 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-green-500 focus:border-green-500">

            <!-- 報告者UUID表示 -->
            <div id="reporter-uuid-display" class="text-xs text-right text-gray-500 mb-4"></div>

            <div id="report-status" class="text-center text-sm mb-4"></div>

            <div class="flex justify-end space-x-3">
                <button onclick="closeModal()" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-semibold rounded-lg transition duration-150">キャンセル</button>
                <button onclick="submitKillReport()" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg transition duration-150">報告確定</button>
            </div>
        </div>
    </div>

    <script>
        // 🚨 設定項目: GAS API URL (ユーザー指定の最新URL)
        const GAS_API_URL = 'https://script.google.com/macros/s/AKfycbxyutpOIZYI9Ce51s4vawk6S460QgM4wYcaLFJKUBi00_LKhNXT9-6N0n178KdoXkP7wg/exec'; 
        // ⚠️ mob_data.jsonは静的ファイルパスを想定
        const STATIC_DATA_URL = './mob_data.json'; 

        // グローバルなデータストア
        let globalMobConfig = {};      
        let globalLocationDef = {};    
        let globalHuntList = [];       
        let globalLocationState = [];  
        let currentFilter = 'ALL';
        let reporterUUID = '';
        
        // 現在開いている詳細パネルのIDを追跡するための変数
        let openMobNameId = null; 

        // リポップ間隔（秒）をランクに応じて設定
        const DEFAULT_INTERVALS = {
            'S': 27000, 
            'A': 300 
        };

        // UI要素
        const mobListContainer = document.getElementById('mob-list-container');
        const loadingStatus = document.getElementById('loading-status');
        const filterTabsContainer = document.getElementById('filter-tabs');
        const maintenanceMessage = document.getElementById('maintenance-message');


        // ====================================================================
        // ユーティリティ関数
        // ====================================================================

        /**
         * 匿名レポート用UUIDを取得・生成します。
         */
        function getReporterUUID() {
            let uuid = localStorage.getItem('reporterUUID');
            if (!uuid) {
                uuid = crypto.randomUUID();
                localStorage.setItem('reporterUUID', uuid);
            }
            return uuid;
        }

        /**
         * UNIXタイムスタンプをJSTの文字列にフォーマットします。
         */
        function formatTimeToJST(timestamp) {
            if (!timestamp) return '不明';
            const date = new Date(timestamp);
            return date.toLocaleTimeString('ja-JP', {
                timeZone: 'Asia/Tokyo',
                year: 'numeric',
                month: 'numeric',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }
        
        /**
         * Dateオブジェクトを <input type="datetime-local"> 形式 (YYYY-MM-DDThh:mm) に変換します。（JSTとして処理）
         */
        function dateToDateTimeLocal(date) {
            const offset = date.getTimezoneOffset() * 60000;
            const jstOffset = 9 * 60 * 60000;
            
            const jstDate = new Date(date.getTime() + offset + jstOffset);

            const pad = (num) => num.toString().padStart(2, '0');
            
            const year = jstDate.getFullYear();
            const month = pad(jstDate.getMonth() + 1);
            const day = pad(jstDate.getDate());
            const hours = pad(jstDate.getHours());
            const minutes = pad(jstDate.getMinutes());
            
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }


        /**
         * テンプレートリテラル内のXSS対策
         */
        function safeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        /**
         * HTML IDとして安全な文字列を生成します。
         */
        function safeId(str) {
            if (!str) return 'id-' + crypto.randomUUID();
            // モンスター名から安全なIDを生成
            return String(str).replace(/\s/g, '_').replace(/[^a-zA-Z0-9_-]/g, '');
        }


        // ====================================================================
        // データ取得 (静的/動的)
        // ====================================================================

        /**
         * 静的なモブ設定データ (mob_data.json) を取得します。
         * ⚠️ 現在はコンテキスト内のmob_data.jsonからデータを読み込むよう変更
         */
        async function fetchStaticData() {
            try {
                // mob_data.jsonの内容を直接使用
                const rawData = {
                  "mobConfig": [
                    { "モブ名": "ナニカ", "ランク": "S", "エリア名": "ラノシア", "リポップ間隔 (秒)": 18000, "POP条件": "特定のエモート", "時間条件": "10:00-14:00", "天候条件": "晴れ", "マップ画像 (ファイル名)": "laluna.jpg" },
                    { "モブ名": "タソガレ", "ランク": "A", "エリア名": "クルザス", "リポップ間隔 (秒)": 3600, "POP条件": "特定のFATE達成", "時間条件": "なし", "天候条件": "吹雪", "マップ画像 (ファイル名)": "kuzasu.jpg" },
                    { "モブ名": "デスフロッグ", "ランク": "FATE", "エリア名": "黒衣森", "リポップ間隔 (秒)": 900, "POP条件": "なし", "時間条件": "なし", "天候条件": "なし", "マップ画像 (ファイル名)": "kurokui.jpg" },
                    { "モブ名": "ゲシュタルト", "ランク": "S", "エリア名": "アバラシア", "リポップ間隔 (秒)": 18000, "POP条件": "時間経過とFATE", "時間条件": "なし", "天候条件": "雷", "マップ画像 (ファイル名)": "abalasia.jpg" }
                  ],
                  "locationDef": [
                    { "モブ名": "ナニカ", "locationId": 1, "coordX": 200, "coordY": 100 },
                    { "モブ名": "ナニカ", "locationId": 2, "coordX": 400, "coordY": 300 },
                    { "モブ名": "ゲシュタルト", "locationId": 1, "coordX": 150, "coordY": 450 }
                  ]
                };

                // mobConfigをオブジェクト形式に変換
                globalMobConfig = rawData.mobConfig.reduce((acc, mob) => {
                    acc[mob["モブ名"]] = mob;
                    return acc;
                }, {});

                // locationDefをモブ名でグループ化
                globalLocationDef = rawData.locationDef.reduce((acc, loc) => {
                    const name = loc["モブ名"];
                    if (!acc[name]) {
                        acc[name] = [];
                    }
                    // キー名を統一
                    acc[name].push({ locationId: loc.locationId, coordX: loc.coordX, coordY: loc.coordY });
                    return acc;
                }, {});

                loadingStatus.textContent = '静的データを正常に読み込みました。リアルタイムデータを取得中です...';
                
                generateTabs(); 

            } catch (error) {
                console.error("Error fetching static data:", error);
                loadingStatus.innerHTML = `
                    <div class="text-red-400">🚨 致命的なエラー: モブ設定データの読み込みに失敗しました。</div>
                    <div class="text-sm mt-2 text-gray-400">
                        コンソールを確認してください。
                    </div>
                `;
                throw error;
            }
        }


        /**
         * Google Apps Script (GAS) API から動的なデータ (ログ、状態) を取得します。
         */
        async function fetchDynamicData() {
            console.log(`[Fetch] Fetching dynamic data from: ${GAS_API_URL}?mode=getdata`);

            // リアルタイムデータ取得のロジックは残しつつ、動作確認のためにダミーデータで初期化
            const dummyHuntList = [
                { mobName: "ナニカ", killTime: new Date(Date.now() - 17000 * 1000).toISOString() }, // 17000秒前 (94%進捗)
                { mobName: "ゲシュタルト", killTime: new Date(Date.now() - 10000 * 1000).toISOString() }, // 10000秒前 (55%進捗)
                { mobName: "タソガレ", killTime: new Date(Date.now() - 1500 * 1000).toISOString() }, // 1500秒前 (41%進捗)
                { mobName: "デスフロッグ", killTime: new Date(Date.now() - 100 * 1000).toISOString() } // 100秒前
            ];
            
            // ダミーのチェックイン状態
            const dummyLocationState = [
                { mobName: "ナニカ", checkedLocationId: 1, reporterId: "dummy1" }
            ];

            try {
                const response = await fetch(`${GAS_API_URL}?mode=getdata`, {
                    method: 'GET',
                    cache: 'no-cache' 
                });

                if (!response.ok) {
                    throw new Error(`GAS API HTTP Error: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                
                if (result.status === 'success') {
                    globalHuntList = result.huntList || dummyHuntList;
                    globalLocationState = result.locationState || dummyLocationState;
                    
                    checkMaintenance(result.maintenance);

                    renderMobList();

                    loadingStatus.classList.add('hidden'); 
                } else {
                    globalHuntList = dummyHuntList;
                    globalLocationState = dummyLocationState;
                    renderMobList();
                    loadingStatus.classList.remove('hidden');
                    loadingStatus.innerHTML = `<div class="text-red-400">🚨 GAS APIエラー: ${result.message} (ダミーデータ表示中)</div>`;
                }

            } catch (error) {
                // 通信エラー時もダミーデータで描画を試みる
                globalHuntList = dummyHuntList;
                globalLocationState = dummyLocationState;
                renderMobList();
                loadingStatus.classList.remove('hidden');
                loadingStatus.innerHTML = `<div class="text-red-400">🚨 リアルタイムデータ取得エラー: ${error.message} (ダミーデータ表示中)</div>`;
            }
        }

        /**
         * メンテナンス情報をチェックし、表示します。
         */
        function checkMaintenance(message) {
            maintenanceMessage.textContent = '';
            maintenanceMessage.classList.add('hidden');
            
            if (message && message.toLowerCase().includes('maintenance')) {
                maintenanceMessage.textContent = '🚨 サーバーメンテナンス情報: ' + message;
                maintenanceMessage.classList.remove('hidden');
            }
        }

        // ====================================================================
        // UI描画関数
        // ====================================================================

        /**
         * タブフィルターを生成します。
         */
        function generateTabs() {
            const ranks = ['ALL', 'S', 'A', 'FATE'];
            filterTabsContainer.innerHTML = ranks.map(rank => `
                <button 
                    onclick="setFilter('${rank}')" 
                    class="tab-button w-full px-4 py-2 text-sm font-semibold rounded-lg bg-gray-600 hover:bg-gray-500 text-white transition duration-150 ${rank === currentFilter ? 'tab-active' : ''}"
                    data-filter="${rank}"
                >
                    ${rank}
                </button>
            `).join('');
        }

        /**
         * フィルターを設定し、リストを再描画します。
         * @param {string} filter - フィルター文字列 (ALL, S, A, FATE)
         */
        function setFilter(filter) {
            currentFilter = filter;
            // フィルタ変更時は詳細を一旦閉じる
            if (openMobNameId) {
                const detailElement = document.getElementById(`detail-${openMobNameId}`);
                const headerElement = document.getElementById(`header-${openMobNameId}`);
                if (detailElement) detailElement.classList.remove('is-open');
                if (headerElement) headerElement.classList.remove('is-expanded');
                openMobNameId = null;
            }
            renderMobList();
            
            // フィルタボタンのハイライトを更新
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('tab-active');
                if (button.dataset.filter === filter) {
                    button.classList.add('tab-active');
                }
            });
        }


        /**
         * モブリスト全体をレンダリングします。
         */
        function renderMobList() {
            const allMobs = Object.keys(globalMobConfig).map(key => {
                const mob = globalMobConfig[key];
                return {
                    ...mob,
                    mobName: mob['モブ名'] || key || '不明なモブ',
                    rank: mob['ランク'] || 'N/A',
                    area: mob['エリア名'] || 'エリア不明',
                    popCondition: mob['POP条件'] || null, 
                    interval: mob['リポップ間隔 (秒)'] || DEFAULT_INTERVALS[mob['ランク']] || 1800,
                    mapFilename: mob['マップ画像 (ファイル名)']
                };
            });

            // FATEランクのフィルタリング ('FATE'または'F')
            let filteredMobs = allMobs.filter(mob => {
                const mobRank = mob.rank || 'N/A';
                if (currentFilter === 'ALL') return true;
                if (currentFilter === 'FATE') return mobRank === 'FATE' || mobRank === 'F'; 
                return mobRank === currentFilter;
            });
            
            // 討伐時間とリポップ率の計算、ソート
            filteredMobs = filteredMobs
                .map(mob => calculateMobTime(mob)) 
                .sort((a, b) => b.progressPercent - a.progressPercent); 

            if (filteredMobs.length === 0) {
                mobListContainer.innerHTML = `<p class="text-center text-gray-400 col-span-full">選択されたランクのモンスターはいません。</p>`;
                return;
            }

            // 新しいリストをレンダリング
            mobListContainer.innerHTML = filteredMobs.map(mob => createMobCard(mob)).join('');

            // 詳細表示の状態を保持 (再レンダリング時に開いていたパネルを復元)
            if (openMobNameId) {
                const detailElement = document.getElementById(`detail-${openMobNameId}`);
                const headerElement = document.getElementById(`header-${openMobNameId}`);


                if (detailElement && headerElement) {
                    // オーバーレイのクラスを即座に追加して表示を復元
                    detailElement.classList.add('is-open');
                    headerElement.classList.add('is-expanded');
                    
                    // マップ再描画
                    const mobToRender = filteredMobs.find(m => safeId(m.mobName) === openMobNameId);
                    if (mobToRender) {
                        renderMap(mobToRender.mobName, mobToRender.area);
                    }
                } else {
                    // 開いていたモブがフィルタリングで非表示になった場合、状態をリセット
                    openMobNameId = null;
                }
            }
        }

        /**
         * 個別のモブカードのHTMLを生成します。
         */
        function createMobCard(mob) {
            const mobName = mob.mobName;
            // MobNameを元にしたIDを使用
            const safeMobNameId = safeId(mobName); 
            
            if (mobName === '不明なモブ') {
                console.warn("Skipping card due to missing mob name:", mob);
                return ''; 
            }

            const lastKillTime = mob.lastKillTime;
            const progressPercent = mob.progressPercent;
            const nextPopTime = mob.nextPopTime;

            const rawMapImageFilename = mob.mapFilename || '';
            // null、undefined、空文字列の全てをカバー
            const hasMap = rawMapImageFilename !== null && rawMapImageFilename !== '';
            
            const mapIcon = hasMap ? '🗺️' : '';
            
            const cardClasses = `mob-card-wrapper transition duration-300`;
            const progressColor = progressPercent > 90 ? 'bg-red-500' : '#68d391'; /* 90%以上は赤 */

            // ランク別カラー設定
            let rankColor = 'bg-gray-600'; // デフォルト
            const mobRank = mob.rank || 'N/A';
            const isSrank = mobRank === 'S'; // Sランク判定

            if (mobRank === 'S') {
                rankColor = 'bg-orange-500'; // S: オレンジ
            } else if (mobRank === 'A') {
                rankColor = 'bg-green-600'; // A: 緑
            } else if (mobRank === 'FATE' || mobRank === 'F') {
                rankColor = 'bg-blue-400'; // FATE: 青
            } 
            
            // POP条件の改行処理 (「//」を<br>に変換して表示)
            const formattedPopCondition = safeHTML(mob.popCondition || '');
            const displayPopCondition = formattedPopCondition.replace(/\/\/\s*/g, '<br>');
            
            const popConditionExists = !!mob.popCondition; // POP条件のデータがあるか
            
            // ----------------------------------------------------
            // 詳細コンテンツの生成
            // ----------------------------------------------------
            let detailContentHTML = '';
            let detailClasses = '';

            if (isSrank) {
                // Sランクの場合
                let popConditionSegment = '';
                if (popConditionExists) {
                    popConditionSegment = `
                        <h4 class="text-sm font-semibold text-white mb-2 border-b border-gray-600 pb-1">POP条件</h4>
                        <p class="mb-3">${displayPopCondition}</p>
                    `;
                }

                let mapSegment = '';
                if (hasMap) {
                    // マップ画像が設定されている場合のみ表示
                    mapSegment = `
                        <div class="mt-4 pt-4 border-t border-gray-600">
                            <h4 class="text-sm font-semibold text-white mb-2">POP候補地 (${safeHTML(mob.area || 'エリア不明')})</h4>
                            <div id="map-canvas-${safeMobNameId}" class="map-container rounded-lg overflow-hidden border border-gray-600">
                                <!-- マップと座標点はここに描画されます -->
                            </div>
                        </div>
                    `;
                } else if (!popConditionExists) {
                     // POP条件もマップもない場合、detail-accordion自体をis-emptyにする
                     detailClasses = 'is-empty';
                }

                detailContentHTML = popConditionSegment + mapSegment;

            } else {
                // Aランク, FATEランクの場合、詳細パネルは空
                detailContentHTML = '';
                detailClasses = 'is-empty'; // A/FATEランクは常にis-emptyとしてCSSで微調整
            }
            // ----------------------------------------------------


            // カード構造: ヘッダーと詳細パネルが兄弟要素として mob-card-wrapper の中に配置される
            // mob-card-wrapper が position: relative なので、detail-accordion はその中にオーバーレイとして表示される
            return `
                <div class="${cardClasses}" data-mob-name="${safeHTML(mobName)}" id="card-${safeMobNameId}">
                    
                    <!-- 1行目と2行目 (ゲージ背景) - クリック可能なヘッダー部分 -->
                    <div 
                        class="mob-card-header relative overflow-hidden bg-[#2d3748]" 
                        id="header-${safeMobNameId}"
                        onclick="toggleMobDetail('${safeMobNameId}', '${safeHTML(mob.area)}')"
                        >
                        
                        <!-- 経過時間ゲージ -->
                        <div class="progress-bar absolute top-0 left-0 h-full z-0" style="width: ${progressPercent}%; background-color: ${progressColor};"></div>
                        
                        <!-- コンテンツレイヤー -->
                        <div class="relative z-10 p-4 min-h-[56px]">
                            <div class="flex justify-between items-start mb-1">
                                
                                <!-- モンスター名とランク、エリア名の表示エリア -->
                                <div class="flex flex-col">
                                    
                                    <!-- 1行目: ランクとモンスター名 -->
                                    <div class="flex items-baseline space-x-2 mb-0.5">
                                        <!-- ランクバッジ: rounded-lgに変更し、paddingを調整 -->
                                        <span class="px-2 py-0.5 text-sm font-bold rounded-lg ${rankColor} text-white flex-shrink-0">${safeHTML(mobRank)}</span>
                                        
                                        <!-- モンスター名 (サイズをtext-lgに縮小) -->
                                        <span class="text-lg font-bold text-white text-outline">${safeHTML(mobName)} ${mapIcon}</span>
                                    </div>
                                    
                                    <!-- 2行目: エリア名 -->
                                    <span class="text-xs text-gray-300" style="margin-left: 2.2rem;">${safeHTML(mob.area || 'エリア不明')}</span>
                                </div>
                                
                                <!-- 報告ボタン (クリックが詳細トグルに伝播しないよう event.stopPropagation() を使用) -->
                                <button 
                                    class="mt-1 px-2 py-1 bg-red-700 hover:bg-red-600 text-xs text-white font-bold rounded-full transition duration-150 flex-shrink-0"
                                    onclick="event.stopPropagation(); openModal('${safeHTML(mobName)}', '${safeHTML(mobRank)}', '${safeHTML(mob.area || 'エリア不明')}')"
                                >
                                    報告
                                </button>
                            </div>
                            
                            <!-- 次回POP時間 (経過%) -->
                            <div class="text-sm font-semibold mt-2">
                                <span class="text-white">次回POP: ${nextPopTime} (${progressPercent.toFixed(1)}%)</span>
                            </div>
                        </div>
                    </div>

                    <!-- 🚨 詳細情報 (オーバーレイ展開部分 - 絶対配置) -->
                    <div id="detail-${safeMobNameId}" class="detail-accordion text-gray-300 ${detailClasses}">
                        
                        <div class="text-xs"> 
                            <!-- 前回の討伐時間 (これは全てのランクで表示) -->
                            <p class="mb-2"><strong>前回討伐:</strong> ${formatTimeToJST(lastKillTime)}</p>
                            
                            ${detailContentHTML}
                        </div>
                    </div>
                </div>
            `;
        }
        
        /**
         * モブの最新の討伐時間からリポップ時間や進捗率を計算します。
         */
        function calculateMobTime(mob) {
            const mobName = mob.mobName;
            const mobRank = mob.rank;
            
            const defaultInterval = DEFAULT_INTERVALS[mobRank] || 1800; 
            const intervalSeconds = mob.interval || defaultInterval;

            const latestKill = globalHuntList
                .filter(log => log.mobName === mobName)
                .sort((a, b) => new Date(b.killTime) - new Date(a.killTime))[0];

            let lastKillTime = null;
            let timeSinceKill = 0;
            let progressPercent = 0;
            let nextPopTime = "討伐報告なし";

            if (latestKill) {
                lastKillTime = new Date(latestKill.killTime).getTime();
                const now = Date.now();
                
                timeSinceKill = Math.floor((now - lastKillTime) / 1000);
                
                progressPercent = Math.min((timeSinceKill / intervalSeconds) * 100, 100);

                const nextPopTimestamp = lastKillTime + (intervalSeconds * 1000);
                nextPopTime = formatTimeToJST(nextPopTimestamp);

                if (progressPercent >= 100) {
                    nextPopTime = "POP可能";
                }
            }

            return {
                ...mob,
                lastKillTime: lastKillTime,
                progressSeconds: timeSinceKill,
                progressPercent: progressPercent,
                nextPopTime: nextPopTime,
            };
        }


        /**
         * モブカードの詳細表示をトグルします。（オーバーレイ）
         * @param {string} mobId - モンスター名に基づく一意のID (safeId(mobName))
         * @param {string} area - エリア名
         */
        function toggleMobDetail(mobId, area) {
            const detailElement = document.getElementById(`detail-${mobId}`);
            const headerElement = document.getElementById(`header-${mobId}`);
            
            if (!detailElement || !headerElement) {
                console.error(`Element not found for ID: ${mobId}`);
                return;
            }

            const isCurrentlyOpen = mobId === openMobNameId; 

            // 1. 他の要素が開いている場合、それを閉じる
            if (openMobNameId && openMobNameId !== mobId) {
                const currentlyOpenDetailEl = document.getElementById(`detail-${openMobNameId}`);
                const currentlyOpenHeaderEl = document.getElementById(`header-${openMobNameId}`);
                
                if (currentlyOpenDetailEl) {
                    currentlyOpenDetailEl.classList.remove('is-open'); 
                }
                if (currentlyOpenHeaderEl) {
                    currentlyOpenHeaderEl.classList.remove('is-expanded');
                }
            }
            
            // 2. 開閉処理
            if (isCurrentlyOpen) {
                // 閉じる
                detailElement.classList.remove('is-open');
                headerElement.classList.remove('is-expanded');
                openMobNameId = null; // トラッカーをリセット

            } else {
                // 開く
                detailElement.classList.add('is-open');
                headerElement.classList.add('is-expanded');
                openMobNameId = mobId; // トラッカーを更新

                // マップの描画
                const mobToRender = Object.values(globalMobConfig).find(m => safeId(m['モブ名']) === mobId);
                if (mobToRender) {
                    renderMap(mobToRender.mobName, area);
                }
            }
        }


        // ====================================================================
        // マップと座標トラッキング
        // ====================================================================
        
        /**
         * 指定されたモブのPOP地点をマップ上に描画します。
         */
        function renderMap(mobName, area) {
            // マップコンテナは mobName を元にした ID を使用
            const safeNameId = safeId(mobName);
            const mapContainer = document.getElementById(`map-canvas-${safeNameId}`);
            
            if (!mapContainer) return;

            const mobConfig = Object.values(globalMobConfig).find(m => m['モブ名'] === mobName);
            const rawMapImageFilename = mobConfig?.['マップ画像 (ファイル名)'] || '';
            
            if (!rawMapImageFilename) {
                // マップ画像がない場合は何もしない 
                return;
            }

            // 既に画像が設定されていれば再描画はドットのみ
            if (!mapContainer.querySelector('img')) {
                // 画像が存在しない場合のフォールバック付き
                const mapImagePath = `./Picture/${rawMapImageFilename.replace(/\s/g, '_')}`; 
                mapContainer.innerHTML = `<img src="${mapImagePath}" onerror="this.onerror=null;this.src='https://placehold.co/500x500/1e293b/94a3b8?text=Map+Not+Found'" alt="${area} Map" class="absolute inset-0">`;
            }

            // 座標データ取得
            const mobLocations = globalLocationDef[mobName] || [];
            
            // 現在チェック済みの座標IDリストを作成
            const checkedLocations = new Set(
                globalLocationState
                    .filter(state => state.mobName === mobName)
                    .map(state => state.checkedLocationId)
            );

            // 既存のドットをクリアしてから再描画
            mapContainer.querySelectorAll('.pop-point').forEach(el => el.remove());

            mobLocations.forEach(loc => {
                const isChecked = checkedLocations.has(loc.locationId);
                
                const point = document.createElement('div');
                point.className = `pop-point transition duration-100 ${isChecked ? 'pop-checked' : 'pop-candidate'}`;
                point.title = `座標ID: ${loc.locationId} (${isChecked ? 'チェック済み' : '候補'})`;
                
                // マップサイズ500x500を基準にパーセンテージ計算
                const xPercent = (loc.coordX / 500) * 100;
                const yPercent = (loc.coordY / 500) * 100;

                point.style.left = `calc(${xPercent}% - 7px)`;
                point.style.top = `calc(${yPercent}% - 7px)`;
                
                point.dataset.mobName = mobName;
                point.dataset.locationId = loc.locationId;
                
                point.onclick = (e) => {
                    e.stopPropagation();
                    handlePopPointClick(mobName, loc.locationId, point);
                };

                mapContainer.appendChild(point);
            });
        }
        
        /**
         * POP地点がクリックされたときの処理（チェックイン）。
         */
        async function handlePopPointClick(mobName, locationId, pointElement) {
            if (pointElement.classList.contains('pop-checked')) {
                console.log(`Location ${locationId} already checked for ${mobName}`);
                return;
            }

            pointElement.classList.add('pop-checked');
            pointElement.classList.remove('pop-candidate');
            pointElement.title = `座標ID: ${locationId} (チェック済み)`;

            const payload = {
                type: 'location',
                mobName: mobName,
                locationId: locationId,
                reporterId: reporterUUID,
            };

            await sendPostRequest(payload, "POP地点のチェックインを報告中...");
            
            fetchDynamicData();
        }

        // ====================================================================
        // 討伐報告モーダル
        // ====================================================================

        /**
         * 報告モーダルを開きます。
         */
        function openModal(mobName, mobRank, mobArea) {
            document.getElementById('modal-title').textContent = `${mobName} 討伐報告`;
            document.getElementById('report-mob-name').value = mobName;
            document.getElementById('report-mob-rank').value = mobRank;
            document.getElementById('report-mob-area').value = mobArea;
            document.getElementById('report-status').textContent = '';
            
            // 1. 現在のJST時刻を datetime-local フォーマットで取得し、デフォルト値に設定
            const now = new Date();
            const nowJST = dateToDateTimeLocal(now);
            document.getElementById('kill-time-input').value = nowJST;

            // 2. 報告者UUIDをマスクして表示 (最初の5桁を表示)
            const maskedUUID = reporterUUID.substring(0, 5) + '*****';
            document.getElementById('reporter-uuid-display').textContent = `報告者ID: ${maskedUUID}`;

            document.getElementById('report-modal').classList.remove('hidden');
        }

        /**
         * 報告モーダルを閉じます。
         */
        function closeModal() {
            document.getElementById('report-modal').classList.add('hidden');
        }

        /**
         * 討伐報告をGASに送信します。
         */
        async function submitKillReport() {
            const mobName = document.getElementById('report-mob-name').value;
            const mobRank = document.getElementById('report-mob-rank').value;
            const mobArea = document.getElementById('report-mob-area').value;
            const killTimeLocal = document.getElementById('kill-time-input').value; 
            const statusElement = document.getElementById('report-status');

            if (!killTimeLocal) {
                loadingStatus.textContent = '🚨 討伐日時を選択してください。';
                loadingStatus.classList.remove('hidden');
                setTimeout(() => loadingStatus.classList.add('hidden'), 3000);
                return;
            }

            const selectedDate = new Date(killTimeLocal);
            const killTimeISO = selectedDate.toISOString(); 

            const payload = {
                type: 'kill',
                mobName: mobName,
                mobRank: mobRank,
                area: mobArea,
                world: 'Ifrit', 
                killTime: killTimeISO, 
                reporterId: reporterUUID,
            };
            
            closeModal(); 

            const result = await sendPostRequest(payload, `${mobName} の討伐を報告中...`);
            
            if (result && result.status === 'success') {
                fetchDynamicData();
                loadingStatus.textContent = `${mobName} の討伐が記録されました。`;
                loadingStatus.classList.remove('hidden');
                setTimeout(() => {
                    loadingStatus.classList.add('hidden');
                }, 3000);
            } else {
                loadingStatus.textContent = `🚨 討伐報告に失敗しました。詳細: ${result.message || '不明なエラー'}`;
                loadingStatus.classList.remove('hidden');
            }
        }
        
        /**
         * GAS APIにPOSTリクエストを送信するヘルパー関数
         */
        async function sendPostRequest(payload, loadingMessage) {
            loadingStatus.textContent = loadingMessage;
            loadingStatus.classList.remove('hidden');

            try {
                const response = await fetch(`${GAS_API_URL}?type=${payload.type}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                    cache: 'no-cache'
                });
                
                const result = await response.json();
                
                loadingStatus.classList.add('hidden');
                return result;

            } catch (error) {
                console.error("POST Request Error:", error);
                loadingStatus.textContent = `🚨 報告エラー: ネットワークまたはGASの応答に失敗しました。`;
                return { status: 'error', message: error.message };
            }
        }


        // ====================================================================
        // アプリケーションの初期化とメインループ
        // ====================================================================

        /**
         * アプリケーションのメイン初期化関数
         */
        async function initApp(initial = true) {
            reporterUUID = getReporterUUID();
            console.log(`[Init] Reporter UUID: ${reporterUUID}`);
            console.log(`[Init] GAS API URL: ${GAS_API_URL}`);

            try {
                // 1. 静的データの取得 (初回起動時のみ)
                if (initial) {
                    await fetchStaticData();
                }

                // 2. 動的データの取得と描画
                await fetchDynamicData();

                // 60秒 (60000ms) ごとに自動更新ループを設定
                if (initial) {
                    setInterval(fetchDynamicData, 60000); 
                }
                
            } catch (error) {
                console.error("Application initialization failed.");
            }
        }

        // DOMContentLoaded後にアプリケーションを起動
        window.onload = function() {
            initApp();
        };

    </script>
</body>
</html>
