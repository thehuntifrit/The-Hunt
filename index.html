<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hunt</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* 基本的なダークモード設定 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* ダークブルー */
            color: #ffffff; /* 白文字 */
        }
        
        /* コンテンツ幅の制御とセンタリング */
        .container {
            max-width: 1536px; /* 2XL相当 */
            margin-left: auto;
            margin-right: auto;
            padding: 0 1rem;
        }

        /* カスタムグリッド（レスポンシブ対応） */
        .mob-grid {
            /* スマホ (デフォルト) */
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }
        /* PC (lg以上) - 512px幅のカードを3カラムで配置 */
        @media (min-width: 1024px) {
            .mob-grid {
                /* 512px (カード幅) * 3 + gap */
                grid-template-columns: repeat(3, 1fr);
            }
        }
        /* タブレット (md以上) - 1カラム幅512pxを中央寄せ */
        @media (min-width: 768px) and (max-width: 1023px) {
            .mob-grid {
                grid-template-columns: 1fr;
            }
            .mob-grid > div {
                max-width: 512px;
                margin-left: auto;
                margin-right: auto;
            }
        }

        /* モブカードの基本スタイル */
        .mob-card {
            background-color: #2d3748; /* カード背景色 (濃いグレー) */
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s, transform 0.2s;
            cursor: pointer;
        }

        .mob-card:hover {
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
        }

        /* 経過時間ゲージのベース */
        .progress-bar {
            height: 100%;
            background-color: #f6e05e; /* パステルイエローグリーン */
            transition: width 0.5s ease-out;
        }

        /* テキストのアウトライン風シャドウ (藍色 #3182ce) */
        .text-outline {
            text-shadow: 
                -1px -1px 0 #3182ce,  
                 1px -1px 0 #3182ce,
                -1px  1px 0 #3182ce,
                 1px  1px 0 #3182ce;
        }

        /* タブのアクティブスタイル */
        .tab-active {
            background-color: #68d391 !important; /* パステル黄緑 */
            color: #1a202c !important; /* 濃い文字色 */
            font-weight: 700;
        }

        /* マップオーバーレイ */
        .map-container {
            position: relative;
            max-width: 500px; /* マップ画像の固定幅 */
            height: 500px; /* マップ画像の固定高さ */
            margin: 0 auto;
        }
        
        .map-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            user-select: none;
        }

        /* POP地点マーカー */
        .pop-point {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid #ffffff;
            cursor: pointer;
            opacity: 0.85;
            transition: transform 0.1s;
        }
        .pop-point:hover {
            transform: scale(1.3);
            opacity: 1;
        }

        /* 状態別カラー */
        /* POP候補地 (緑) */
        .pop-candidate {
            background-color: #48bb78; /* Tailwind green-500 */
        }
        /* チェック済み (POPしなかった、赤) */
        .pop-checked {
            background-color: #e53e3e; /* Tailwind red-600 */
        }

        /* メンテナンス情報 */
        #maintenance-message {
            color: #fc8181; /* 赤文字 */
            font-weight: 700;
            padding: 0.5rem;
            margin-top: 0.5rem;
            text-align: center;
        }

        /* スライドトランジション */
        .slide-up-down {
            transition: all 0.3s ease-in-out;
            opacity: 1;
            max-height: 1000px;
        }
        .slide-up-down.hidden {
            opacity: 0;
            max-height: 0;
            padding: 0 1rem;
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <div class="container py-8">
        <!-- サイトタイトルと説明 -->
        <header class="text-center mb-8">
            <h1 class="text-5xl font-extrabold mb-2 text-yellow-400">The Hunt</h1>
            <p id="site-description" class="text-gray-300">
                エオルゼアのモブハント情報をリアルタイムで追跡し、POP地点を共有するためのツールです。（仮説明）
                <br>
                <span class="text-sm text-yellow-400">現在、Ifritワールド専用で運用中。</span>
            </p>
            <!-- メンテナンス情報表示エリア -->
            <p id="maintenance-message" class="hidden"></p>
        </header>
        
        <!-- タブフィルター -->
        <div id="filter-tabs" class="flex justify-center space-x-2 mb-6 p-1 bg-gray-700 rounded-lg">
            <!-- タブはJavaScriptで生成されます -->
        </div>

        <!-- 読み込み中/エラーメッセージ -->
        <div id="loading-status" class="text-center text-xl p-4 rounded-lg bg-yellow-900/50">
            データを読み込み中です...
        </div>

        <!-- モブ一覧コンテナ -->
        <div id="mob-list-container" class="mob-grid">
            <!-- モブカードはJavaScriptでここに挿入されます -->
        </div>
    </div>

    <!-- 討伐報告モーダル -->
    <div id="report-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-gray-800 p-6 rounded-xl w-11/12 max-w-sm">
            <h2 id="modal-title" class="text-2xl font-bold mb-4 text-white">討伐報告</h2>
            <p class="text-gray-300 mb-4">モブを討伐したワールドを選択してください。</p>
            
            <input type="hidden" id="report-mob-name">
            <input type="hidden" id="report-mob-rank">
            <input type="hidden" id="report-mob-area">

            <label for="world-select" class="block text-sm font-medium text-gray-400 mb-1">討伐ワールド</label>
            <select id="world-select" class="w-full p-2 mb-4 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-green-500 focus:border-green-500">
                <!-- ワールドリストはJavaScriptで設定されます -->
            </select>

            <div id="report-status" class="text-center text-sm mb-4"></div>

            <div class="flex justify-end space-x-3">
                <button onclick="closeModal()" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-semibold rounded-lg transition duration-150">キャンセル</button>
                <button onclick="submitKillReport()" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg transition duration-150">報告</button>
            </div>
        </div>
    </div>

    <script>
        // 🚨 設定項目: GAS API URL (必ずデプロイ後に書き換えてください)
        const GAS_API_URL = 'https://script.google.com/macros/s/AKfycbxyutpOIZYI9Ce51s4vawk6S460QgM4wYcaLFJKUBi00_LKhNXT9-6N0n178KdoXkP7wg/exec'; 
        const STATIC_DATA_URL = './mob_data.json'; 

        // グローバルなデータストア
        let globalMobConfig = {};      // mob_data.json から取得する静的設定
        let globalLocationDef = {};    // mob_data.json から取得する座標定義
        let globalHuntList = [];       // GASから取得する最新の討伐履歴
        let globalLocationState = [];  // GASから取得する最新のチェックイン状態
        let currentFilter = 'ALL';
        let reporterUUID = '';

        // Ifritサーバーのみに設定 (ユーザー要望)
        const WORLDS = ['Ifrit'];

        // リポップ間隔（秒）をランクに応じて設定（mob_data.jsonにない場合のデフォルト値）
        const DEFAULT_INTERVALS = {
            'S': 27000, // 7.5時間
            'A': 300 // 5分 (仮)
        };

        // UI要素
        const mobListContainer = document.getElementById('mob-list-container');
        const loadingStatus = document.getElementById('loading-status');
        const filterTabsContainer = document.getElementById('filter-tabs');
        const maintenanceMessage = document.getElementById('maintenance-message');


        // ====================================================================
        // ユーティリティ関数
        // ====================================================================

        /**
         * 匿名レポート用UUIDを取得・生成します。
         */
        function getReporterUUID() {
            let uuid = localStorage.getItem('reporterUUID');
            if (!uuid) {
                // UUIDを生成 (簡易版)
                uuid = crypto.randomUUID();
                localStorage.setItem('reporterUUID', uuid);
            }
            return uuid;
        }

        /**
         * UNIXタイムスタンプをJSTの文字列にフォーマットします。
         */
        function formatTimeToJST(timestamp) {
            if (!timestamp) return '不明';
            const date = new Date(timestamp);
            return date.toLocaleTimeString('ja-JP', {
                timeZone: 'Asia/Tokyo',
                year: 'numeric',
                month: 'numeric',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        /**
         * 秒を H:M:S 形式に変換します。
         */
        function secondsToHms(totalSeconds) {
            if (totalSeconds < 0) return "POP待ち...";
            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = Math.floor(totalSeconds % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }
        
        /**
         * テンプレートリテラル内のXSS対策
         */
        function safeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        /**
         * HTML IDとして安全な文字列を生成します。
         * スペースや特殊文字をアンダースコアに変換し、空の場合はUUIDを返します。（ID重複対策）
         */
        function safeId(str) {
            if (!str) return 'id-' + crypto.randomUUID();
            // スペース、特殊文字、日本語などを除去し、安全な文字のみ残す
            return String(str).replace(/\s/g, '_').replace(/[^a-zA-Z0-9_-]/g, '');
        }


        // ====================================================================
        // データ取得 (静的/動的)
        // ====================================================================

        /**
         * 静的なモブ設定データ (mob_data.json) を取得します。
         */
        async function fetchStaticData() {
            try {
                const response = await fetch(STATIC_DATA_URL);
                if (!response.ok) {
                    throw new Error(`Failed to fetch static data: ${response.statusText}`);
                }
                const data = await response.json();
                
                // global変数を更新
                globalMobConfig = data.mobConfig || {};
                globalLocationDef = data.locationDef || {};

                loadingStatus.textContent = '静的データを正常に読み込みました。リアルタイムデータを取得中です...';
                
                // タブの生成
                generateTabs(); 

            } catch (error) {
                console.error("Error fetching static data:", error);
                loadingStatus.innerHTML = `
                    <div class="text-red-400">🚨 致命的なエラー: モブ設定データの読み込みに失敗しました。</div>
                    <div class="text-sm mt-2 text-gray-400">
                        mob_data.jsonファイルが存在しないか、JSONの形式が正しくありません。コンソールを確認してください。
                    </div>
                `;
                throw error; // アプリの続行を停止
            }
        }

        /**
         * Google Apps Script (GAS) API から動的なデータ (ログ、状態) を取得します。
         */
        async function fetchDynamicData() {
            if (GAS_API_URL === 'YOUR_GAS_WEB_APP_URL') {
                console.error("🚨 GAS_API_URLが設定されていません!");
                loadingStatus.innerHTML = '<div class="text-red-400">🚨 GAS API URLが設定されていません。index.htmlのコードを修正してください。</div>';
                return;
            }

            // ログの表示
            console.log(`[Fetch] Fetching dynamic data from: ${GAS_API_URL}?mode=getdata`);

            try {
                const response = await fetch(`${GAS_API_URL}?mode=getdata`, {
                    method: 'GET',
                    cache: 'no-cache' // キャッシュを無効化して最新データを取得
                });

                // GASからのレスポンスは常に200 OKとして返されるため、ステータスチェックは不要だが、念のため
                if (!response.ok) {
                    throw new Error(`GAS API HTTP Error: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();

                if (result.status === 'success') {
                    // グローバル変数を更新
                    globalHuntList = result.huntList || [];
                    globalLocationState = result.locationState || [];
                    
                    // メンテナンス情報を処理
                    checkMaintenance(result.maintenance);

                    // リストを再描画
                    renderMobList();

                    loadingStatus.classList.add('hidden'); // 読み込みメッセージを非表示に
                } else {
                    // GASからのカスタムエラーメッセージを処理
                    throw new Error(`GAS API Error: ${result.message}`);
                }

            } catch (error) {
                console.error("Error fetching dynamic data from GAS:", error);
                loadingStatus.classList.remove('hidden');
                loadingStatus.innerHTML = `<div class="text-red-400">🚨 リアルタイムデータ取得エラー: ${error.message}</div>`;
            }
        }

        /**
         * メンテナンス情報をチェックし、表示します。
         */
        function checkMaintenance(message) {
            maintenanceMessage.textContent = '';
            maintenanceMessage.classList.add('hidden');
            
            if (message && message.toLowerCase().includes('maintenance')) {
                // 簡易的なチェック。実際は正確な日付パースロジックが必要だが、ここではテキストが存在する場合に表示
                maintenanceMessage.textContent = '🚨 サーバーメンテナンス情報: ' + message;
                maintenanceMessage.classList.remove('hidden');
            }
        }

        // ====================================================================
        // UI描画関数
        // ====================================================================

        /**
         * タブフィルターを生成します。
         */
        function generateTabs() {
            const ranks = ['ALL', 'S', 'A', 'FATE'];
            filterTabsContainer.innerHTML = ranks.map(rank => `
                <button 
                    onclick="setFilter('${rank}')" 
                    class="tab-button px-4 py-2 text-sm font-semibold rounded-lg bg-gray-600 hover:bg-gray-500 text-white transition duration-150 ${rank === currentFilter ? 'tab-active' : ''}"
                    data-filter="${rank}"
                >
                    ${rank}
                </button>
            `).join('');
        }

        /**
         * フィルターを設定し、リストを再描画します。
         * @param {string} filter - フィルター文字列 (ALL, S, A, FATE)
         */
        function setFilter(filter) {
            currentFilter = filter;
            renderMobList();
            
            // タブのアクティブクラスを切り替える
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('tab-active');
                if (button.dataset.filter === filter) {
                    button.classList.add('tab-active');
                }
            });
        }


        /**
         * モブリスト全体をレンダリングします。
         */
        function renderMobList() {
            // mobConfig (静的データ) を配列に変換し、mobNameを確実に設定
            // mobConfigのキーはモンスター名であると想定し、データオブジェクトにmobNameプロパティがない場合のフォールバックとして使用
            const allMobs = Object.keys(globalMobConfig).map(key => ({
                ...globalMobConfig[key],
                // データのmobNameプロパティ、またはキー、または'不明なモブ'を使用
                mobName: globalMobConfig[key].mobName || key || '不明なモブ'
            }));

            // フィルター処理
            let filteredMobs = allMobs.filter(mob => {
                const mobRank = mob.rank || 'N/A';
                if (currentFilter === 'ALL') return true;
                if (currentFilter === 'FATE') return mobRank === 'FATE'; // FATEランクを仮定
                return mobRank === currentFilter;
            });
            
            // 討伐時間とリポップ率の計算、ソート
            filteredMobs = filteredMobs
                .map(mob => calculateMobTime(mob))
                .sort((a, b) => b.progressPercent - a.progressPercent); // 経過%で降順ソート

            if (filteredMobs.length === 0) {
                mobListContainer.innerHTML = `<p class="text-center text-gray-400 col-span-full">選択されたランクのモンスターはいません。</p>`;
                return;
            }

            mobListContainer.innerHTML = filteredMobs.map(mob => createMobCard(mob)).join('');
        }

        /**
         * 個別のモブカードのHTMLを生成します。
         */
        function createMobCard(mob) {
            const mobName = mob.mobName || '不明なモブ';
            const safeMobNameId = safeId(mobName); // モンスター名から安全なIDを生成（ID重複対策）
            
            if (mobName === '不明なモブ') {
                console.warn("Skipping card due to missing mob name:", mob);
                return ''; // モンスター名がない場合はカードをスキップ
            }

            const lastKillTime = mob.lastKillTime;
            const progressPercent = mob.progressPercent;
            const nextPopTime = mob.nextPopTime;

            // マップアイコンとパスの設定
            const rawMapImageFilename = mob['マップ画像 (ファイル名)'] || '';
            const hasMap = rawMapImageFilename !== '';
            
            // rawMapImageFilename が存在するか確認し、ファイル名対策を行う
            const mapImagePath = rawMapImageFilename
                ? `./Picture/${rawMapImageFilename.replace(/\s/g, '_')}`
                : '';

            const mapIcon = hasMap ? '🗺️' : '';
            
            const cardClasses = `mob-card p-0 transition duration-300`;
            const progressColor = progressPercent > 90 ? 'bg-red-500' : '#68d391'; /* 90%以上は赤 */

            // ランク別カラー設定 (青背景白文字)
            let rankColor = '';
            if (mob.rank === 'S') {
                rankColor = 'bg-blue-600';
            } else if (mob.rank === 'A') {
                rankColor = 'bg-green-600';
            } else {
                rankColor = 'bg-gray-600';
            }

            return `
                <div class="${cardClasses}" onclick="toggleMobDetail('${safeHTML(mobName)}', '${safeHTML(mob.area)}')" data-mob-name="${safeHTML(mobName)}">
                    
                    <!-- 1行目と2行目 (ゲージ背景) -->
                    <div class="relative overflow-hidden">
                        <!-- 経過時間ゲージ -->
                        <div class="progress-bar absolute top-0 left-0 h-full z-0" style="width: ${progressPercent}%; background-color: ${progressColor};"></div>
                        
                        <!-- コンテンツレイヤー -->
                        <div class="relative z-10 p-4">
                            <div class="flex justify-between items-start mb-1">
                                <!-- モンスター名, エリア名, ランク -->
                                <div class="flex flex-col">
                                    <span class="text-xl font-bold text-white text-outline">${safeHTML(mobName)} ${mapIcon}</span>
                                    <span class="text-sm text-gray-300">${safeHTML(mob.area || 'エリア不明')}</span>
                                </div>
                                <!-- ランクと報告ボタン -->
                                <div class="flex flex-col items-end">
                                    <span class="px-2 py-1 text-sm font-bold rounded-full ${rankColor} text-white">${safeHTML(mob.rank || 'N/A')}</span>
                                    <button 
                                        class="mt-1 px-2 py-1 bg-red-700 hover:bg-red-600 text-xs text-white font-bold rounded-full transition duration-150"
                                        onclick="event.stopPropagation(); openModal('${safeHTML(mobName)}', '${safeHTML(mob.rank || 'N/A')}', '${safeHTML(mob.area || 'エリア不明')}')"
                                    >
                                        報告
                                    </button>
                                </div>
                            </div>
                            
                            <!-- 次回POP時間 (経過%) -->
                            <div class="text-sm font-semibold mt-2">
                                <span class="text-white">次回POP: ${nextPopTime} (${progressPercent.toFixed(1)}%)</span>
                            </div>
                        </div>
                    </div>

                    <!-- 詳細情報 (スライド表示部分) -->
                    <div id="detail-${safeMobNameId}" class="detail-content slide-up-down hidden bg-gray-700 text-gray-300 p-4 pt-2">
                        <div class="text-xs border-t border-gray-600 pt-2">
                            <!-- 前回の討伐時間 -->
                            <p class="mb-1"><strong>前回討伐:</strong> ${formatTimeToJST(lastKillTime)}</p>
                            
                            <!-- POPさせる条件の説明 -->
                            <p class="mb-2"><strong>POP条件:</strong> ${safeHTML(mob.popCondition || 'なし')}</p>
                            
                            <!-- 座標記録用のMAP -->
                            ${hasMap ? `
                                <div class="mt-4">
                                    <h4 class="text-md font-semibold text-white mb-2">POP候補地 (${safeHTML(mob.area || 'エリア不明')})</h4>
                                    <div id="map-canvas-${safeMobNameId}" class="map-container rounded-lg overflow-hidden border border-gray-600">
                                        <!-- マップと座標点はここに描画されます -->
                                    </div>
                                </div>
                            ` : `<p class="mt-4">このモブのマップ座標データはありません。</p>`}
                        </div>
                    </div>
                </div>
            `;
        }
        
        /**
         * モブの最新の討伐時間からリポップ時間や進捗率を計算します。
         */
        function calculateMobTime(mob) {
            const mobName = mob.mobName || '不明なモブ';
            const mobRank = mob.rank;
            const defaultInterval = DEFAULT_INTERVALS[mobRank] || 1800; // 30分をデフォルト

            // 1. 最新の討伐ログを検索
            const latestKill = globalHuntList
                .filter(log => log.mobName === mobName)
                .sort((a, b) => new Date(b.killTime) - new Date(a.killTime))[0];

            let lastKillTime = null;
            let timeSinceKill = 0;
            let progressPercent = 0;
            let nextPopTime = "討伐報告なし";

            if (latestKill) {
                lastKillTime = new Date(latestKill.killTime).getTime();
                const intervalSeconds = mob['リポップ間隔 (秒)'] || defaultInterval;
                const now = Date.now();
                
                timeSinceKill = Math.floor((now - lastKillTime) / 1000);
                
                progressPercent = Math.min((timeSinceKill / intervalSeconds) * 100, 100);

                const nextPopTimestamp = lastKillTime + (intervalSeconds * 1000);
                nextPopTime = formatTimeToJST(nextPopTimestamp);

                if (progressPercent >= 100) {
                    nextPopTime = "POP可能";
                }
            }

            // モブオブジェクトに計算結果を追加
            return {
                ...mob,
                lastKillTime: lastKillTime,
                progressSeconds: timeSinceKill,
                progressPercent: progressPercent,
                nextPopTime: nextPopTime,
            };
        }


        /**
         * モブカードの詳細表示をトグルします。
         */
        function toggleMobDetail(mobName, area) {
            const safeNameId = safeId(mobName);
            const detailElement = document.getElementById(`detail-${safeNameId}`);
            
            if (!detailElement) {
                console.error(`Detail element not found for mob: ${mobName} (ID: detail-${safeNameId})`);
                return;
            }

            // スライドアニメーション
            if (detailElement.classList.contains('hidden')) {
                // 開く処理
                // 一旦hiddenを外し、max-heightとopacityをリセットしてアニメーションを有効にする
                detailElement.classList.remove('hidden');
                setTimeout(() => {
                    detailElement.style.maxHeight = '1000px'; 
                    detailElement.style.opacity = '1';
                }, 10);
                
                // マップの描画を呼び出し
                renderMap(mobName, area);
            } else {
                // 閉じる処理
                detailElement.style.maxHeight = '0';
                detailElement.style.opacity = '0';
                setTimeout(() => {
                    detailElement.classList.add('hidden');
                }, 300); // CSSのtransition時間と合わせる
            }
        }


        // ====================================================================
        // マップと座標トラッキング
        // ====================================================================
        
        /**
         * 指定されたモブのPOP地点をマップ上に描画します。
         */
        function renderMap(mobName, area) {
            const safeNameId = safeId(mobName);
            const mapContainer = document.getElementById(`map-canvas-${safeNameId}`);
            
            if (!mapContainer) return;

            // マップ画像を特定
            const mobConfig = Object.values(globalMobConfig).find(m => (m.mobName || Object.keys(globalMobConfig).find(k => globalMobConfig[k] === m) || '不明なモブ') === mobName);
            const rawMapImageFilename = mobConfig?.['マップ画像 (ファイル名)'] || '';
            
            if (!rawMapImageFilename) {
                mapContainer.innerHTML = `<p class="text-center text-gray-500 py-4">マップ画像が設定されていません。</p>`;
                return;
            }

            // 既に画像が設定されていれば再描画はドットのみ
            if (!mapContainer.querySelector('img')) {
                const mapImagePath = `./Picture/${rawMapImageFilename.replace(/\s/g, '_')}`;
                mapContainer.innerHTML = `<img src="${mapImagePath}" alt="${area} Map" class="absolute inset-0">`;
            }

            // 座標データ取得
            const mobLocations = globalLocationDef[mobName] || [];
            
            // 現在チェック済みの座標IDリストを作成
            const checkedLocations = new Set(
                globalLocationState
                    .filter(state => state.mobName === mobName)
                    .map(state => state.checkedLocationId)
            );

            // 既存のドットをクリアしてから再描画
            mapContainer.querySelectorAll('.pop-point').forEach(el => el.remove());

            mobLocations.forEach(loc => {
                const isChecked = checkedLocations.has(loc.locationId);
                
                const point = document.createElement('div');
                point.className = `pop-point transition duration-100 ${isChecked ? 'pop-checked' : 'pop-candidate'}`;
                point.title = `座標ID: ${loc.locationId} (${isChecked ? 'チェック済み' : '候補'})`;
                
                // マップサイズ500x500を基準にパーセンテージで位置を計算
                // X, Yがシートに数値として格納されていることを前提
                const xPercent = (loc.coordX / 500) * 100;
                const yPercent = (loc.coordY / 500) * 100;

                // 中央寄せのためにドットの半分のサイズ(7px)を引く
                point.style.left = `calc(${xPercent}% - 7px)`;
                point.style.top = `calc(${yPercent}% - 7px)`;
                
                point.dataset.mobName = mobName;
                point.dataset.locationId = loc.locationId;
                
                // クリックイベントハンドラを設定
                point.onclick = (e) => {
                    e.stopPropagation();
                    handlePopPointClick(mobName, loc.locationId, point);
                };

                mapContainer.appendChild(point);
            });
        }
        
        /**
         * POP地点がクリックされたときの処理（チェックイン）。
         */
        async function handlePopPointClick(mobName, locationId, pointElement) {
            if (pointElement.classList.contains('pop-checked')) {
                // すでにチェック済みの場合は何もしない（削除機能は複雑なので一旦除外）
                console.log(`Location ${locationId} already checked for ${mobName}`);
                return;
            }

            pointElement.classList.add('pop-checked');
            pointElement.classList.remove('pop-candidate');
            pointElement.title = `座標ID: ${locationId} (チェック済み)`;

            const payload = {
                type: 'location',
                mobName: mobName,
                locationId: locationId,
                reporterId: reporterUUID,
            };

            await sendPostRequest(payload, "POP地点のチェックインを報告中...");
            
            // 報告が成功したら、動的データを再取得して全体を更新
            fetchDynamicData();
        }

        // ====================================================================
        // 討伐報告モーダル
        // ====================================================================

        /**
         * 報告モーダルを開きます。
         */
        function openModal(mobName, mobRank, mobArea) {
            document.getElementById('modal-title').textContent = `${mobName} 討伐報告`;
            document.getElementById('report-mob-name').value = mobName;
            document.getElementById('report-mob-rank').value = mobRank;
            document.getElementById('report-mob-area').value = mobArea;
            document.getElementById('report-status').textContent = '';
            document.getElementById('world-select').value = WORLDS[0]; // デフォルト値を設定

            // ワールド選択肢の生成
            const worldSelect = document.getElementById('world-select');
            // Ifritのみ表示
            worldSelect.innerHTML = WORLDS.map(w => `<option value="${safeHTML(w)}">${safeHTML(w)}</option>`).join('');

            document.getElementById('report-modal').classList.remove('hidden');
        }

        /**
         * 報告モーダルを閉じます。
         */
        function closeModal() {
            document.getElementById('report-modal').classList.add('hidden');
        }

        /**
         * 討伐報告をGASに送信します。
         */
        async function submitKillReport() {
            const mobName = document.getElementById('report-mob-name').value;
            const mobRank = document.getElementById('report-mob-rank').value;
            const mobArea = document.getElementById('report-mob-area').value;
            const world = document.getElementById('world-select').value;
            const statusElement = document.getElementById('report-status');

            const payload = {
                type: 'kill',
                mobName: mobName,
                mobRank: mobRank,
                area: mobArea,
                world: world,
                reporterId: reporterUUID,
            };
            
            closeModal(); // モーダルを閉じる

            const result = await sendPostRequest(payload, `${mobName} の討伐を報告中...`);
            
            if (result && result.status === 'success') {
                // 討伐報告が成功したら、動的データを再取得してタイマーをリセット
                fetchDynamicData();
                loadingStatus.textContent = `${mobName} の討伐が記録されました。`;
                loadingStatus.classList.remove('hidden');
                setTimeout(() => {
                    loadingStatus.classList.add('hidden');
                }, 3000);
            } else {
                alert('討伐報告に失敗しました。GASのログを確認してください。');
            }
        }
        
        /**
         * GAS APIにPOSTリクエストを送信するヘルパー関数
         */
        async function sendPostRequest(payload, loadingMessage) {
            loadingStatus.textContent = loadingMessage;
            loadingStatus.classList.remove('hidden');

            try {
                const response = await fetch(`${GAS_API_URL}?type=${payload.type}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                    cache: 'no-cache'
                });
                
                const result = await response.json();
                
                loadingStatus.classList.add('hidden');
                return result;

            } catch (error) {
                console.error("POST Request Error:", error);
                loadingStatus.textContent = `🚨 報告エラー: ネットワークまたはGASの応答に失敗しました。`;
                return { status: 'error', message: error.message };
            }
        }


        // ====================================================================
        // アプリケーションの初期化とメインループ
        // ====================================================================

        /**
         * アプリケーションのメイン初期化関数
         */
        async function initApp(initial = true) {
            reporterUUID = getReporterUUID();
            console.log(`[Init] Reporter UUID: ${reporterUUID}`);
            console.log(`[Init] GAS API URL: ${GAS_API_URL}`);

            try {
                // 1. 静的データの取得 (初回起動時のみ)
                if (initial) {
                    await fetchStaticData();
                }

                // 2. 動的データの取得と描画
                await fetchDynamicData();

                // 3. 30秒ごとに自動更新ループを設定 (初回起動時のみ)
                if (initial) {
                    setInterval(fetchDynamicData, 30000); 
                }
                
            } catch (error) {
                // エラーはfetchStaticData/fetchDynamicData内で処理済み
                console.error("Application initialization failed.");
            }
        }

        // DOMContentLoaded後にアプリケーションを起動
        window.onload = function() {
            initApp();
        };

    </script>
</body>
</html>
